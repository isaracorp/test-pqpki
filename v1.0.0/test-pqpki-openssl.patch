diff --git a/apps/Makefile b/apps/Makefile
index 06bb588..a06e5de 100644
--- a/apps/Makefile
+++ b/apps/Makefile
@@ -39,7 +39,9 @@ E_EXE=	verify asn1pars req dgst dh dhparam enc passwd gendh errstr \
 	ca crl rsa rsautl dsa dsaparam ec ecparam \
 	x509 genrsa gendsa genpkey s_server s_client speed \
 	s_time version pkcs7 cms crl2pkcs7 sess_id ciphers nseq pkcs12 \
-	pkcs8 pkey pkeyparam pkeyutl spkac smime rand engine ocsp prime ts srp
+	pkcs8 pkey pkeyparam pkeyutl spkac smime rand engine ocsp prime ts srp \
+	QSExtend/reqQSExtend QSExtend/x509QSDirectExtend \
+	QSExtend/x509QSExtend QSExtend/x509QSVerify
 
 
 PROGS= $(PROGRAM).c
@@ -57,7 +59,9 @@ E_OBJ=	verify.o asn1pars.o req.o dgst.o dh.o dhparam.o enc.o passwd.o gendh.o er
 	x509.o genrsa.o gendsa.o genpkey.o s_server.o s_client.o speed.o \
 	s_time.o $(A_OBJ) $(S_OBJ) $(RAND_OBJ) version.o sess_id.o \
 	ciphers.o nseq.o pkcs12.o pkcs8.o pkey.o pkeyparam.o pkeyutl.o \
-	spkac.o smime.o cms.o rand.o engine.o ocsp.o prime.o ts.o srp.o
+	spkac.o smime.o cms.o rand.o engine.o ocsp.o prime.o ts.o srp.o \
+	QSExtend/reqQSExtend.o QSExtend/x509QSDirectExtend.o \
+	QSExtend/x509QSExtend.o QSExtend/x509QSVerify.o
 
 E_SRC=	verify.c asn1pars.c req.c dgst.c dh.c enc.c passwd.c gendh.c errstr.c ca.c \
 	pkcs7.c crl2p7.c crl.c \
@@ -65,7 +69,9 @@ E_SRC=	verify.c asn1pars.c req.c dgst.c dh.c enc.c passwd.c gendh.c errstr.c ca.
 	x509.c genrsa.c gendsa.c genpkey.c s_server.c s_client.c speed.c \
 	s_time.c $(A_SRC) $(S_SRC) $(RAND_SRC) version.c sess_id.c \
 	ciphers.c nseq.c pkcs12.c pkcs8.c pkey.c pkeyparam.c pkeyutl.c \
-	spkac.c smime.c cms.c rand.c engine.c ocsp.c prime.c ts.c srp.c
+	spkac.c smime.c cms.c rand.c engine.c ocsp.c prime.c ts.c srp.c \
+	QSExtend/reqQSExtend.c QSExtend/x509QSDirectExtend.c \
+	QSExtend/x509QSExtend.c QSExtend/x509QSVerify.c
 
 SRC=$(E_SRC)
 
@@ -146,6 +152,7 @@ dclean:
 clean:
 	rm -f *.o *.obj *.dll lib tags core .pure .nfs* *.old *.bak fluff $(EXE)
 	rm -f req
+	rm -f QSExtend/*.o
 
 $(DLIBSSL):
 	(cd ..; $(MAKE) build_libssl)
@@ -753,6 +760,22 @@ req.o: ../include/openssl/stack.h ../include/openssl/symhacks.h
 req.o: ../include/openssl/txt_db.h ../include/openssl/ui.h
 req.o: ../include/openssl/x509.h ../include/openssl/x509_vfy.h
 req.o: ../include/openssl/x509v3.h apps.h req.c
+reqQSExtend.o: ../e_os.h ../include/../apps/apps.h ../include/openssl/asn1.h
+reqQSExtend.o: ../include/openssl/bio.h ../include/openssl/buffer.h
+reqQSExtend.o: ../include/openssl/conf.h ../include/openssl/crypto.h
+reqQSExtend.o: ../include/openssl/e_os2.h ../include/openssl/ec.h
+reqQSExtend.o: ../include/openssl/ecdh.h ../include/openssl/ecdsa.h
+reqQSExtend.o: ../include/openssl/engine.h ../include/openssl/err.h
+reqQSExtend.o: ../include/openssl/evp.h ../include/openssl/lhash.h
+reqQSExtend.o: ../include/openssl/obj_mac.h ../include/openssl/objects.h
+reqQSExtend.o: ../include/openssl/ocsp.h ../include/openssl/opensslconf.h
+reqQSExtend.o: ../include/openssl/opensslv.h ../include/openssl/ossl_typ.h
+reqQSExtend.o: ../include/openssl/pem.h ../include/openssl/pem2.h
+reqQSExtend.o: ../include/openssl/pkcs7.h ../include/openssl/safestack.h
+reqQSExtend.o: ../include/openssl/sha.h ../include/openssl/stack.h
+reqQSExtend.o: ../include/openssl/symhacks.h ../include/openssl/txt_db.h
+reqQSExtend.o: ../include/openssl/x509.h ../include/openssl/x509_vfy.h
+reqQSExtend.o: ../include/openssl/x509v3.h QSExtend/reqQSExtend.c reqQSExtend.c
 rsa.o: ../e_os.h ../include/openssl/asn1.h ../include/openssl/bio.h
 rsa.o: ../include/openssl/bn.h ../include/openssl/buffer.h
 rsa.o: ../include/openssl/conf.h ../include/openssl/crypto.h
@@ -1060,3 +1083,55 @@ x509.o: ../include/openssl/sha.h ../include/openssl/stack.h
 x509.o: ../include/openssl/symhacks.h ../include/openssl/txt_db.h
 x509.o: ../include/openssl/x509.h ../include/openssl/x509_vfy.h
 x509.o: ../include/openssl/x509v3.h apps.h x509.c
+x509QSDirectExtend.o: ../e_os.h ../include/../apps/apps.h
+x509QSDirectExtend.o: ../include/openssl/asn1.h ../include/openssl/bio.h
+x509QSDirectExtend.o: ../include/openssl/buffer.h ../include/openssl/conf.h
+x509QSDirectExtend.o: ../include/openssl/crypto.h ../include/openssl/e_os2.h
+x509QSDirectExtend.o: ../include/openssl/ec.h ../include/openssl/ecdh.h
+x509QSDirectExtend.o: ../include/openssl/ecdsa.h ../include/openssl/engine.h
+x509QSDirectExtend.o: ../include/openssl/err.h ../include/openssl/evp.h
+x509QSDirectExtend.o: ../include/openssl/lhash.h ../include/openssl/obj_mac.h
+x509QSDirectExtend.o: ../include/openssl/objects.h ../include/openssl/ocsp.h
+x509QSDirectExtend.o: ../include/openssl/opensslconf.h
+x509QSDirectExtend.o: ../include/openssl/opensslv.h
+x509QSDirectExtend.o: ../include/openssl/ossl_typ.h ../include/openssl/pem.h
+x509QSDirectExtend.o: ../include/openssl/pem2.h ../include/openssl/pkcs7.h
+x509QSDirectExtend.o: ../include/openssl/safestack.h ../include/openssl/sha.h
+x509QSDirectExtend.o: ../include/openssl/stack.h ../include/openssl/symhacks.h
+x509QSDirectExtend.o: ../include/openssl/txt_db.h ../include/openssl/x509.h
+x509QSDirectExtend.o: ../include/openssl/x509_vfy.h ../include/openssl/x509v3.h
+x509QSDirectExtend.o: QSExtend/x509QSDirectExtend.c x509QSDirectExtend.c
+x509QSExtend.o: ../e_os.h ../include/../apps/apps.h ../include/openssl/asn1.h
+x509QSExtend.o: ../include/openssl/asn1_mac.h ../include/openssl/bio.h
+x509QSExtend.o: ../include/openssl/buffer.h ../include/openssl/conf.h
+x509QSExtend.o: ../include/openssl/crypto.h ../include/openssl/e_os2.h
+x509QSExtend.o: ../include/openssl/ec.h ../include/openssl/ecdh.h
+x509QSExtend.o: ../include/openssl/ecdsa.h ../include/openssl/engine.h
+x509QSExtend.o: ../include/openssl/err.h ../include/openssl/evp.h
+x509QSExtend.o: ../include/openssl/lhash.h ../include/openssl/obj_mac.h
+x509QSExtend.o: ../include/openssl/objects.h ../include/openssl/ocsp.h
+x509QSExtend.o: ../include/openssl/opensslconf.h ../include/openssl/opensslv.h
+x509QSExtend.o: ../include/openssl/ossl_typ.h ../include/openssl/pem.h
+x509QSExtend.o: ../include/openssl/pem2.h ../include/openssl/pkcs7.h
+x509QSExtend.o: ../include/openssl/safestack.h ../include/openssl/sha.h
+x509QSExtend.o: ../include/openssl/stack.h ../include/openssl/symhacks.h
+x509QSExtend.o: ../include/openssl/txt_db.h ../include/openssl/x509.h
+x509QSExtend.o: ../include/openssl/x509_vfy.h ../include/openssl/x509v3.h
+x509QSExtend.o: QSExtend/x509QSExtend.c x509QSExtend.c
+x509QSVerify.o: ../e_os.h ../include/../apps/apps.h ../include/openssl/asn1.h
+x509QSVerify.o: ../include/openssl/bio.h ../include/openssl/buffer.h
+x509QSVerify.o: ../include/openssl/conf.h ../include/openssl/crypto.h
+x509QSVerify.o: ../include/openssl/e_os2.h ../include/openssl/ec.h
+x509QSVerify.o: ../include/openssl/ecdh.h ../include/openssl/ecdsa.h
+x509QSVerify.o: ../include/openssl/engine.h ../include/openssl/err.h
+x509QSVerify.o: ../include/openssl/evp.h ../include/openssl/lhash.h
+x509QSVerify.o: ../include/openssl/obj_mac.h ../include/openssl/objects.h
+x509QSVerify.o: ../include/openssl/ocsp.h ../include/openssl/opensslconf.h
+x509QSVerify.o: ../include/openssl/opensslv.h ../include/openssl/ossl_typ.h
+x509QSVerify.o: ../include/openssl/pem.h ../include/openssl/pem2.h
+x509QSVerify.o: ../include/openssl/pkcs7.h ../include/openssl/safestack.h
+x509QSVerify.o: ../include/openssl/sha.h ../include/openssl/stack.h
+x509QSVerify.o: ../include/openssl/symhacks.h ../include/openssl/txt_db.h
+x509QSVerify.o: ../include/openssl/x509.h ../include/openssl/x509_vfy.h
+x509QSVerify.o: ../include/openssl/x509v3.h QSExtend/x509QSVerify.c
+x509QSVerify.o: x509QSVerify.c
diff --git a/apps/QSExtend/reqQSExtend.c b/apps/QSExtend/reqQSExtend.c
new file mode 100644
index 0000000..7e85623
--- /dev/null
+++ b/apps/QSExtend/reqQSExtend.c
@@ -0,0 +1,651 @@
+/** @file reqQSExtend.c Load QS keypair and traditional CSR and use them to create multiple public key algorithm CSR.
+ *
+ * Isara Corporation Quantum Safe EST Proprietary Software License
+ * Statement
+ *
+ * LICENSE AGREEMENT: The Product(s) that reference this license include
+ * embedded proprietary software and software “plug-ins” in source code or
+ * object code or both (the “Software”) and accompanying materials (the
+ * “Documentation”) that are subject to the license terms and restrictions
+ * described below (the “License"). If you do not agree to the License
+ * terms, do not use the Product, notify Isara Corporation (“Isara”) by
+ * electronic mail at sales@isara.com and erase any copies of the Product
+ * in your possession. If you are entering into this License on behalf of
+ * a company or other legal entity, you represent that you have the right
+ * to bind that entity to all terms, and “you” refers both to you
+ * personally and such entity.
+ *
+ * USE AND DISTRIBUTION: You may use the Software only in the form and in
+ * the Product(s) delivered to you for the purposes of integration,
+ * development and testing with your own products and/or as part of a
+ * monitoring and/or control group beta test with third parties that agree
+ * in writing to be bound by the terms of this License.
+ *
+ * ADDITIONAL RESTRICTIONS: You shall not use, modify, reproduce, reverse
+ * engineer, disassemble, decompile or otherwise attempt to derive source
+ * code from the Software (except to the extent that such limitations may
+ * not be prohibited by law), sublicense, or distribute the Software or
+ * Documentation other than as permitted by this License. You shall not
+ * remove any proprietary notices, labels or marks on the Product(s) “ZIP
+ * file”, Software or Documentation. No license is granted to use or
+ * reproduce any Isara trademarks.
+ *
+ * OWNERSHIP AND NOTICE: Except for the limited rights granted above,
+ * Isara and its suppliers retain all right, title and interest in and to
+ * the Software and Documentation, including copyrights, patents, trade
+ * secrets and other proprietary rights. Certain components of the
+ * Software that are subject to open source and third party licenses, the
+ * terms and conditions of which can found at https://github.com/cisco and
+ * select the applicable hash-sigs or libest license filed on the Github
+ * repository. If you require additional guidance, notify sales@isara.com
+ * for assistance. As a condition of the License, you agree to comply with
+ * all of the foregoing open source and third party license terms. Unless
+ * required by applicable law, such components are provided on an ‘AS IS’
+ * BASIS, WITHOUT EXPRESS OR IMPLIED WARRANTIES OR CONDITIONS OF ANY KIND.
+ *
+ * WARRANTY DISCLAIMER: THE SOFTWARE AND DOCUMENTATION ARE PROVIDED TO YOU
+ * "AS IS", AND YOU ASSUME THE ENTIRE RISK OF THEIR USE. ISARA AND ITS
+ * SUPPLIERS MAKES NO WARRANTIES OR CONDITIONS, EXPRESS, IMPLIED,
+ * STATUTORY OR IN ANY COMMUNICATION WITH YOU, AND ISARA CORPORATION
+ * EXPRESSLY DISCLAIMS ANY IMPLIED WARRANTIES OF MERCHANTABILITY, FITNESS
+ * FOR A PARTICULAR PURPOSE OR NONINFRINGEMENT WITH RESPECT TO THE
+ * SOFTWARE (INCLUDING ANY MODIFICATIONS MADE THERETO BY ANY PERSON
+ * WHETHER OR NOT AN EMPLOYEE OR CONTRACTOR OF ISARA) OR DOCUMENTATION
+ * PROVIDED TO YOU. ISARA EMPLOYEES AND OTHER PERSONNEL ARE NOT AUTHORIZED
+ * TO MAKE ANY WARRANTY THAT IS INCONSISTENT WITH THIS DISCLAIMER.
+ *
+ * LIMITATION OF LIABILITY: IN NO EVENT WILL ISARA OR ITS SUPPLIERS AND
+ * SUPPLIERS BE LIABLE FOR LOSS OF DATA, LOST PROFITS, COST OF COVER, OR
+ * OTHER SPECIAL, INCIDENTAL, PUNITIVE, CONSEQUENTIAL, OR INDIRECT DAMAGES
+ * ARISING FROM USE OF THE SOFTWARE OR DOCUMENTATION, HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, AND REGARDLESS OF WHETHER ISARA OR ITS
+ * SUPPLIERS HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  ISARA
+ * AND ITS SUPPLIERS BEAR NO LIABILITY FOR ANY PROGRAMS OR DATA STORED IN
+ * OR USED WITH THIS PRODUCT, INCLUDING THE COST OF RECOVERING SUCH
+ * PROGRAMS OR DATA.
+ *
+ * Copyright (c) 2017 ISARA Corporation. All Rights Reserved. This file
+ * contains Proprietary information of Isara Corporation. Unauthorized
+ * copying or use of this file via any medium is strictly prohibited.
+ * Written by Anthony Hu, anthony.hu@isara.com; Daniel Van Geest,
+ * daniel.vangeest@isara.com, December, 2017.
+ */
+
+/* Modified.  Was genpkey.c.
+ */
+
+/* Written by Dr Stephen N Henson (steve@openssl.org) for the OpenSSL project
+ * 2006
+ */
+/* ====================================================================
+ * Copyright (c) 2006 The OpenSSL Project.  All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * 3. All advertising materials mentioning features or use of this
+ *    software must display the following acknowledgment:
+ *    "This product includes software developed by the OpenSSL Project
+ *    for use in the OpenSSL Toolkit. (http://www.OpenSSL.org/)"
+ *
+ * 4. The names "OpenSSL Toolkit" and "OpenSSL Project" must not be used to
+ *    endorse or promote products derived from this software without
+ *    prior written permission. For written permission, please contact
+ *    licensing@OpenSSL.org.
+ *
+ * 5. Products derived from this software may not be called "OpenSSL"
+ *    nor may "OpenSSL" appear in their names without prior written
+ *    permission of the OpenSSL Project.
+ *
+ * 6. Redistributions of any form whatsoever must retain the following
+ *    acknowledgment:
+ *    "This product includes software developed by the OpenSSL Project
+ *    for use in the OpenSSL Toolkit (http://www.OpenSSL.org/)"
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE OpenSSL PROJECT ``AS IS'' AND ANY
+ * EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE OpenSSL PROJECT OR
+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
+ * OF THE POSSIBILITY OF SUCH DAMAGE.
+ * ====================================================================
+ *
+ * This product includes cryptographic software written by Eric Young
+ * (eay@cryptsoft.com).  This product includes software written by Tim
+ * Hudson (tjh@cryptsoft.com).
+ *
+ */
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+
+#include "../apps/apps.h"
+#include <openssl/pem.h>
+#include <openssl/err.h>
+#include <openssl/evp.h>
+#include <openssl/engine.h>
+#include <openssl/x509v3.h>
+
+X509_ATTRIBUTE *create_SAPKI_ATTRIBUTE(SUBJECT_ALT_PUBLIC_KEY_INFO *sapki) {
+    unsigned char *p = NULL;
+    unsigned char *data = NULL;
+    ASN1_STRING *seq = NULL;
+    int i = 0;
+    int total = 0;
+    X509_ATTRIBUTE *attr = NULL;
+
+    i = i2d_SUBJECT_ALT_PUBLIC_KEY_INFO(sapki, NULL);
+    if (i < 0) {
+        fprintf(stderr, "Failed to get ASN.1 size of SAPKI attribute.\n");
+        goto end;
+    }
+
+    total = ASN1_object_size(1,i,V_ASN1_SEQUENCE);
+
+    data = OPENSSL_malloc(total);
+    if (data == NULL) {
+        fprintf(stderr, "Memory failure during SAPKI attribute creation.\n");
+        goto end;
+    }
+
+    p=data;
+    ASN1_put_object(&p, 1, i, V_ASN1_SEQUENCE,V_ASN1_UNIVERSAL);
+    i = i2d_SUBJECT_ALT_PUBLIC_KEY_INFO(sapki, &p);
+    if (i < 0) {
+        fprintf(stderr, "Failed to ASN.1 encode the SAPKI attribute.\n");
+        goto end;
+    }
+
+    seq = ASN1_STRING_new();
+    if (!ASN1_STRING_set(seq, data, total)) {
+        fprintf(stderr, "Failed to alloc/set string for SAPKI attribute.\n");
+        ASN1_STRING_free(seq);
+        goto end;
+    }
+
+    attr = X509_ATTRIBUTE_create(NID_subj_alt_pub_key, V_ASN1_SEQUENCE, seq);
+    if (attr == NULL) {
+        fprintf(stderr, "Failed to create the SAPKI attribute.\n");
+        goto end;
+    }
+
+end:
+    OPENSSL_free(data);
+    return attr;
+}
+
+X509_ATTRIBUTE *create_ALTSIG_ATTRIBUTE(ASN1_BIT_STRING *altsig) {
+    X509_ATTRIBUTE *attr = NULL;
+
+    attr = X509_ATTRIBUTE_create(NID_alt_sigval, V_ASN1_BIT_STRING, altsig);
+    if (attr == NULL) {
+        fprintf(stderr, "Failed to create the ALTSIG attribute.\n");
+        goto end;
+    }
+
+end:
+    return attr;
+}
+
+X509_ATTRIBUTE *create_ALTSIGALG_ATTRIBUTE(X509_ALGOR *altsigalg) {
+    X509_ATTRIBUTE *attr = NULL;
+    unsigned char *p = NULL;
+    unsigned char *data = NULL;
+    ASN1_STRING *astr = NULL;
+    int i = 0;
+
+    i = i2d_X509_ALGOR(altsigalg, NULL);
+    if (i < 0) {
+        fprintf(stderr, "Failed to get ASN.1 size of ALTSIGALG attribute.\n");
+        goto end;
+    }
+
+    data = OPENSSL_malloc(i);
+    if (data == NULL) {
+        fprintf(stderr, "Memory failure during ALTSIGALG attribute creation.\n");
+        goto end;
+    }
+
+    p=data;
+    i = i2d_X509_ALGOR(altsigalg, &p);
+    if (i < 0) {
+        fprintf(stderr, "Failed to ASN.1 encode the ALTSIGALG attribute.\n");
+        goto end;
+    }
+
+    astr = ASN1_STRING_new();
+    if (!ASN1_STRING_set(astr, data, i)) {
+        fprintf(stderr, "Failed to alloc/set string for ALTSIGALG attribute.\n");
+        ASN1_STRING_free(astr);
+        goto end;
+    }
+
+    attr = X509_ATTRIBUTE_create(NID_alt_sigalg, V_ASN1_SEQUENCE, astr);
+    if (attr == NULL) {
+        ASN1_STRING_free(astr);
+        fprintf(stderr, "Failed to create the ALTSIGALG attribute.\n");
+        goto end;
+    }
+
+end:
+    OPENSSL_free(data);
+    return attr;
+}
+
+#undef PROG
+#define PROG    reqQSExtend_main
+
+int MAIN(int, char **);
+
+int MAIN(int argc, char **argv)
+{
+    char **args;
+    int badarg = 0;
+    int ret = 1;
+    char *passin = NULL;
+    char *passin_qs = NULL;
+    char *passargin = NULL;
+    char *passargin_qs = NULL;
+
+    ENGINE *e = NULL;
+    EVP_PKEY_CTX *tmpctx = NULL;
+    EVP_PKEY *pkey_qs_priv = NULL;
+    EVP_PKEY *pkey_qs_pub = NULL;
+    EVP_PKEY *classical_privkey = NULL;
+
+    BIO *bio_reqin = NULL;
+    BIO *bio_reqout = NULL;
+    const char *file_priv = NULL;
+    const char *file_qs_pub = NULL;
+    const char *file_qs_priv = NULL;
+
+    X509_REQ *req = NULL;
+    ASN1_BIT_STRING *qs_sigval_as_asn1bitstring = NULL;
+
+    int snid = -1;
+    X509_ALGOR *qssig_algor = NULL;
+    ASN1_BIT_STRING *qssig = NULL;
+    X509_ATTRIBUTE *attr_qssig = NULL;
+
+    X509_ATTRIBUTE *attr_qssigalg = NULL;
+
+    X509_PUBKEY *x509_pub_qs = NULL;
+    X509_PUBKEY *x509_sig_qs = NULL;
+    SUBJECT_ALT_PUBLIC_KEY_INFO *sapki = NULL;
+    X509_ATTRIBUTE *attr_sapki = NULL;
+
+    unsigned char *sign_in = NULL;
+    size_t sign_in_size = 0;
+    unsigned char *sign_out = NULL;
+    size_t sign_out_size = 0;
+
+    EVP_MD_CTX mctx;
+
+    const EVP_MD *md_alg = EVP_sha512();
+
+    EVP_MD_CTX_init(&mctx);
+    bio_err = BIO_new_fp(stderr, BIO_NOCLOSE);
+
+    CRYPTO_malloc_debug_init();
+    CRYPTO_set_mem_debug_options(V_CRYPTO_MDEBUG_ALL);
+    CRYPTO_mem_ctrl(CRYPTO_MEM_CHECK_ON);
+
+    ERR_load_crypto_strings();
+    ENGINE_load_dynamic();
+
+    args = argv + 1;
+    while (!badarg && *args && *args[0] == '-') {
+        if (strcmp(*args, "-engine") == 0) {
+            if (!args[1])
+                goto bad;
+            e = setup_engine(bio_err, *(++args), 0);
+            if (e == NULL)
+                goto end;
+        } else if (strcmp(*args, "-reqin") == 0) {
+            if (!args[1])
+                goto bad;
+            bio_reqin = BIO_new_file(*(++args), "rb");
+        } else if (strcmp(*args, "-reqout") == 0) {
+            if (!args[1])
+                goto bad;
+            bio_reqout = BIO_new_file(*(++args), "wb");
+        } else if (strcmp(*args, "-privin") == 0) {
+            if (!args[1])
+                goto bad;
+            file_priv = *(++args);
+        } else if (strcmp(*args, "-pubqs") == 0) {
+            if (!args[1])
+                goto bad;
+            file_qs_pub = *(++args);
+        } else if (strcmp(*args, "-privqs") == 0) {
+            if (!args[1])
+                goto bad;
+            file_qs_priv = *(++args);
+        } else if (strcmp(*argv, "-passin") == 0) {
+            if (--argc < 1)
+                goto bad;
+            passargin = *(++argv);
+        } else if (strcmp(*argv, "-passinqs") == 0) {
+            if (--argc < 1)
+                goto bad;
+            passargin_qs = *(++argv);
+        } else {
+            badarg = 1;
+        }
+        args++;
+    }
+
+    if (file_priv == NULL)
+        badarg = 1;
+
+    if (bio_reqin == NULL)
+        badarg = 1;
+
+    if (bio_reqout == NULL)
+        badarg = 1;
+
+    if (file_qs_priv == NULL)
+        badarg = 1;
+
+    if (badarg) {
+bad:
+        BIO_printf(bio_err, "Usage: openssl reqQSExtend [options]\n");
+        BIO_printf(bio_err, "where options may be\n");
+        BIO_printf(bio_err,
+                   "-engine e          Use Engine library <e>.\n");
+        BIO_printf(bio_err,
+                   "-reqin file        The CSR in pem format.\n");
+        BIO_printf(bio_err,
+                   "-reqout file       The CSR in pem format with new ALT extensions.\n");
+        BIO_printf(bio_err,
+                   "-privin file       The private key used to sign the original CSR in pem format.\n");
+        BIO_printf(bio_err,
+                   "-pubqs file        The public QS key.\n");
+        BIO_printf(bio_err,
+                   "-privqs file       The private QS key.\n");
+        BIO_printf(bio_err,
+                   "-passin            The private key password source.\n");
+        BIO_printf(bio_err,
+                   "-passinqs          The private QS key password source.\n");
+        goto end;
+    }
+
+    if (!app_passwd(bio_err, passargin, NULL, &passin, NULL)) {
+        BIO_printf(bio_err, "Error getting password for the private key.\n");
+        goto end;
+    }
+
+    if (!app_passwd(bio_err, passargin_qs, NULL, &passin_qs, NULL)) {
+        BIO_printf(bio_err, "Error getting password for the QS private key.\n");
+        goto end;
+    }
+
+    /* Read in the the classical req. */
+    req = PEM_read_bio_X509_REQ(bio_reqin, NULL, NULL, NULL);
+    if (req == NULL) {
+        BIO_printf(bio_err, "Bad CSR\n");
+        goto end;
+    }
+
+    /* Read in the classical private key.  We'll need it to sign the
+     * QS req again.
+     */
+    classical_privkey = load_key(bio_err, file_priv, FORMAT_PEM, 0, passin, e, "Classical Private Key");
+    if (classical_privkey == NULL) {
+        /* load_key() has already printed an appropriate message. */
+        goto end;
+    }
+
+    /* Read in the QS private key so we can create a QS signature */
+    pkey_qs_priv = load_key(bio_err, file_qs_priv, FORMAT_PEM, 0, passin_qs, e, "QS Private Key");
+    if (pkey_qs_priv == NULL) {
+        /* load_key() has already printed an appropriate message. */
+        goto end;
+    }
+
+    /* Ensure the private key is actually a QS key */
+    if (pkey_qs_priv->type != NID_hss) {
+        BIO_puts(bio_err, "The provided private key is not compatible with a quantum safe algorithm.\n");
+        goto end;
+    }
+
+    /* Read the QS Public key to be embedded in the QS req if it was specified.
+     * If not check the private key.
+     */
+    if (file_qs_pub == NULL) {
+        pkey_qs_pub = pkey_qs_priv;
+    } else {
+        pkey_qs_pub = load_pubkey(bio_err, file_qs_pub, FORMAT_PEM, 0, NULL, e, "QS Public Key");
+        if (pkey_qs_pub == NULL) {
+            /* load_pubkey() has already printed an appropriate message. */
+            goto end;
+        }
+    }
+
+    if (pkey_qs_priv->type == NID_hss) {
+        /* Create a temporary context */
+        tmpctx = EVP_PKEY_CTX_new(pkey_qs_priv, NULL);
+        if (tmpctx == NULL) {
+           BIO_printf(bio_err, "Could not create context.\n");
+           goto end;
+        }
+
+        /* Send the control string. */
+        if (EVP_PKEY_CTX_ctrl_str(tmpctx, set_hss_private_key_file_ctrl_string, file_qs_priv) <= 0) {
+            BIO_printf(bio_err, "Couldn't set HSS private key file.\n");
+            goto end;
+        }
+
+        /* All the work for the tmpctx is done. */
+        EVP_PKEY_CTX_free(tmpctx);
+        tmpctx = NULL;
+    }
+
+    /* Ensure the public key is actually a QR key */
+    if (pkey_qs_pub->type != NID_hss) {
+        BIO_puts(bio_err, "The provided public key is not compatible with a quantum safe algorithm.\n");
+        goto end;
+    }
+
+    /* Convert the private key into an x509 public key.  This lets us
+     * get the algorithm identifier of the private key so we can associate
+     * it with the signature.
+     */
+    X509_PUBKEY_set(&x509_sig_qs, pkey_qs_priv);
+
+    /* Convert the pkey in to an x509 public key.  This is the standard way
+     * of doing it for x509 subject public key.
+     */
+    X509_PUBKEY_set(&x509_pub_qs, pkey_qs_pub);
+
+    sapki = SUBJECT_ALT_PUBLIC_KEY_INFO_new();
+    if (sapki == NULL) {
+        BIO_puts(bio_err, "Error converting public key to x509 pubkey\n");
+        goto end;
+    }
+
+    X509_ALGOR_free(sapki->algor);
+    ASN1_BIT_STRING_free(sapki->public_key);
+
+    sapki->algor = x509_pub_qs->algor;
+    sapki->public_key = x509_pub_qs->public_key;
+
+    /* Create and insert QS public key as an extension */
+    attr_sapki = create_SAPKI_ATTRIBUTE(sapki);
+    sapki->algor = NULL;
+    sapki->public_key = NULL;
+    if (attr_sapki == NULL) {
+        BIO_puts(bio_err, "Error converting x509 pubkey to extension.\n");
+        goto end;
+    }
+
+    /* Add the ALT public key extension so the signing process includes it.
+     */
+    if (X509_REQ_add1_attr(req, attr_sapki) == 0) {
+        BIO_puts(bio_err, "Error adding public key as extension\n");
+        goto end;
+    }
+
+    qssig_algor = X509_ALGOR_dup(x509_sig_qs->algor);
+    if (qssig_algor == NULL) {
+        BIO_puts(bio_err, "Error duplicating signature algor.\n");
+        goto end;
+    }
+
+    /* Make sure that the right digest is set. */
+    if (!OBJ_find_sigid_by_algs(&snid, NID_sha512, EVP_PKEY_id(pkey_qs_priv))) {
+        BIO_puts(bio_err, "Error getting NID for digest/signature algorithm combination.\n");
+        goto end;
+    }
+
+    if (X509_ALGOR_set0(qssig_algor, OBJ_nid2obj(snid), V_ASN1_UNDEF, 0) == 0) {
+        BIO_puts(bio_err, "Error setting algorithm object ID.\n");
+        goto end;
+    }
+
+    attr_qssigalg = create_ALTSIGALG_ATTRIBUTE(qssig_algor);
+
+    /* Add the ALT signature algorithm extension so the signing process includes it.
+     */
+    if (X509_REQ_add1_attr(req, attr_qssigalg) == 0) {
+        BIO_puts(bio_err, "Error adding signature algorithm as extension\n");
+        goto end;
+    }
+
+    req->req_info->enc.modified = 1;
+
+    /* Sign the req with the QS private key. */
+    if (EVP_DigestSignInit(&mctx, NULL, md_alg, NULL, pkey_qs_priv) < 1) {
+        BIO_puts(bio_err, "Error doing EVP digest initialization\n");
+        goto end;
+    }
+
+    sign_in_size = ASN1_item_i2d((ASN1_VALUE *)req->req_info, &sign_in, ASN1_ITEM_rptr(X509_REQ_INFO));
+
+    sign_out_size = EVP_PKEY_size(pkey_qs_priv);
+    sign_out = OPENSSL_malloc(sign_out_size);
+    if ((sign_in == NULL) || (sign_out == NULL)) {
+        BIO_puts(bio_err, "Memory allocation error for signing input or output.\n");
+        goto end;
+    }
+
+    if (!EVP_DigestSignUpdate(&mctx, sign_in, sign_in_size)
+        || !EVP_DigestSignFinal(&mctx, sign_out, &sign_out_size)) {
+        BIO_puts(bio_err, "EVP digest/sign operation error.\n");
+        goto end;
+    }
+
+    /* Prepare an ASN1 bit string for the ALT signature extension. */
+    qs_sigval_as_asn1bitstring = ASN1_BIT_STRING_new();
+    if (qs_sigval_as_asn1bitstring == NULL) {
+         BIO_puts(bio_err, "ASN1 bit string memory allocation error.\n");
+         goto end;
+    }
+
+    qs_sigval_as_asn1bitstring->flags &= ~(ASN1_STRING_FLAG_BITS_LEFT | 0x07);
+    qs_sigval_as_asn1bitstring->flags |= ASN1_STRING_FLAG_BITS_LEFT;
+    qs_sigval_as_asn1bitstring->data = sign_out;
+    qs_sigval_as_asn1bitstring->length = sign_out_size;
+
+    /* Transferred ownership of the buffer to qs_sigval_as_asn1bitstring. */
+    sign_out = NULL;
+    sign_out_size = 0;
+
+    attr_qssig = create_ALTSIG_ATTRIBUTE(qs_sigval_as_asn1bitstring);
+    if (attr_qssig == NULL) {
+        BIO_puts(bio_err, "Error creating signature extension.\n");
+        goto end;
+    }
+    qs_sigval_as_asn1bitstring = NULL;
+
+    if (X509_REQ_add1_attr(req, attr_qssig) == 0) {
+        BIO_puts(bio_err, "Error adding signature as extension\n");
+        goto end;
+    }
+
+    req->req_info->enc.modified = 1;
+
+    /* Re-sign the req with the original classical private key. */
+    if (X509_REQ_sign(req, classical_privkey, NULL) == 0) {
+        BIO_puts(bio_err, "Error generating classical signature.\n");
+        goto end;
+    }
+
+    /* write the new signed req with extensions in it. */
+    if (PEM_write_bio_X509_REQ(bio_reqout, req) == 0) {
+        BIO_puts(bio_err, "Error writing new CSR.\n");
+        goto end;
+    }
+
+    ret = 0;
+
+ end:
+    if (ret != 0)
+        ERR_print_errors(bio_err);
+
+    EVP_MD_CTX_cleanup(&mctx);
+    if (tmpctx)
+        EVP_PKEY_CTX_free(tmpctx);
+    if (bio_reqin)
+        BIO_free_all(bio_reqin);
+    if (bio_reqout)
+        BIO_free_all(bio_reqout);
+    if (req)
+        X509_REQ_free(req);
+    if (pkey_qs_pub == pkey_qs_priv)
+        pkey_qs_pub = NULL;
+    if (pkey_qs_pub)
+        EVP_PKEY_free(pkey_qs_pub);
+    if (pkey_qs_priv)
+        EVP_PKEY_free(pkey_qs_priv);
+    if (classical_privkey)
+        EVP_PKEY_free(classical_privkey);
+    if (x509_pub_qs)
+        X509_PUBKEY_free(x509_pub_qs);
+    if (x509_sig_qs)
+        X509_PUBKEY_free(x509_sig_qs);
+    if (qssig_algor)
+        X509_ALGOR_free(qssig_algor);
+    if (sapki)
+        SUBJECT_ALT_PUBLIC_KEY_INFO_free(sapki);
+    if (qssig)
+        ASN1_BIT_STRING_free(qssig);
+
+    /* Note that we use OPENSSL_malloc() to allocate these so we don't use
+     * the custom free functions to free them.
+     */
+    OPENSSL_free(sign_out);
+    OPENSSL_free(sign_in);
+    if (qs_sigval_as_asn1bitstring)
+        ASN1_BIT_STRING_free(qs_sigval_as_asn1bitstring);
+    if (attr_sapki)
+        X509_ATTRIBUTE_free(attr_sapki);
+    if (attr_qssig)
+        X509_ATTRIBUTE_free(attr_qssig);
+    if (attr_qssigalg)
+        X509_ATTRIBUTE_free(attr_qssigalg);
+
+    if (passargin && passin)
+        OPENSSL_free(passin);
+    if (passargin_qs && passin_qs)
+        OPENSSL_free(passin_qs);
+    release_engine(e);
+    OBJ_cleanup();
+    apps_shutdown();
+    OPENSSL_EXIT(ret);
+}
diff --git a/apps/QSExtend/x509QSDirectExtend.c b/apps/QSExtend/x509QSDirectExtend.c
new file mode 100644
index 0000000..b366575
--- /dev/null
+++ b/apps/QSExtend/x509QSDirectExtend.c
@@ -0,0 +1,576 @@
+/** @file x509QSDirectExtend.c Load QS keypair and traditional X509 certificates and use them to create a multiple public key algorithm certificate.
+ *
+ * Isara Corporation Quantum Safe EST Proprietary Software License
+ * Statement
+ *
+ * LICENSE AGREEMENT: The Product(s) that reference this license include
+ * embedded proprietary software and software “plug-ins” in source code or
+ * object code or both (the “Software”) and accompanying materials (the
+ * “Documentation”) that are subject to the license terms and restrictions
+ * described below (the “License"). If you do not agree to the License
+ * terms, do not use the Product, notify Isara Corporation (“Isara”) by
+ * electronic mail at sales@isara.com and erase any copies of the Product
+ * in your possession. If you are entering into this License on behalf of
+ * a company or other legal entity, you represent that you have the right
+ * to bind that entity to all terms, and “you” refers both to you
+ * personally and such entity.
+ *
+ * USE AND DISTRIBUTION: You may use the Software only in the form and in
+ * the Product(s) delivered to you for the purposes of integration,
+ * development and testing with your own products and/or as part of a
+ * monitoring and/or control group beta test with third parties that agree
+ * in writing to be bound by the terms of this License.
+ *
+ * ADDITIONAL RESTRICTIONS: You shall not use, modify, reproduce, reverse
+ * engineer, disassemble, decompile or otherwise attempt to derive source
+ * code from the Software (except to the extent that such limitations may
+ * not be prohibited by law), sublicense, or distribute the Software or
+ * Documentation other than as permitted by this License. You shall not
+ * remove any proprietary notices, labels or marks on the Product(s) “ZIP
+ * file”, Software or Documentation. No license is granted to use or
+ * reproduce any Isara trademarks.
+ *
+ * OWNERSHIP AND NOTICE: Except for the limited rights granted above,
+ * Isara and its suppliers retain all right, title and interest in and to
+ * the Software and Documentation, including copyrights, patents, trade
+ * secrets and other proprietary rights. Certain components of the
+ * Software that are subject to open source and third party licenses, the
+ * terms and conditions of which can found at https://github.com/cisco and
+ * select the applicable hash-sigs or libest license filed on the Github
+ * repository. If you require additional guidance, notify sales@isara.com
+ * for assistance. As a condition of the License, you agree to comply with
+ * all of the foregoing open source and third party license terms. Unless
+ * required by applicable law, such components are provided on an ‘AS IS’
+ * BASIS, WITHOUT EXPRESS OR IMPLIED WARRANTIES OR CONDITIONS OF ANY KIND.
+ *
+ * WARRANTY DISCLAIMER: THE SOFTWARE AND DOCUMENTATION ARE PROVIDED TO YOU
+ * "AS IS", AND YOU ASSUME THE ENTIRE RISK OF THEIR USE. ISARA AND ITS
+ * SUPPLIERS MAKES NO WARRANTIES OR CONDITIONS, EXPRESS, IMPLIED,
+ * STATUTORY OR IN ANY COMMUNICATION WITH YOU, AND ISARA CORPORATION
+ * EXPRESSLY DISCLAIMS ANY IMPLIED WARRANTIES OF MERCHANTABILITY, FITNESS
+ * FOR A PARTICULAR PURPOSE OR NONINFRINGEMENT WITH RESPECT TO THE
+ * SOFTWARE (INCLUDING ANY MODIFICATIONS MADE THERETO BY ANY PERSON
+ * WHETHER OR NOT AN EMPLOYEE OR CONTRACTOR OF ISARA) OR DOCUMENTATION
+ * PROVIDED TO YOU. ISARA EMPLOYEES AND OTHER PERSONNEL ARE NOT AUTHORIZED
+ * TO MAKE ANY WARRANTY THAT IS INCONSISTENT WITH THIS DISCLAIMER.
+ *
+ * LIMITATION OF LIABILITY: IN NO EVENT WILL ISARA OR ITS SUPPLIERS AND
+ * SUPPLIERS BE LIABLE FOR LOSS OF DATA, LOST PROFITS, COST OF COVER, OR
+ * OTHER SPECIAL, INCIDENTAL, PUNITIVE, CONSEQUENTIAL, OR INDIRECT DAMAGES
+ * ARISING FROM USE OF THE SOFTWARE OR DOCUMENTATION, HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, AND REGARDLESS OF WHETHER ISARA OR ITS
+ * SUPPLIERS HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  ISARA
+ * AND ITS SUPPLIERS BEAR NO LIABILITY FOR ANY PROGRAMS OR DATA STORED IN
+ * OR USED WITH THIS PRODUCT, INCLUDING THE COST OF RECOVERING SUCH
+ * PROGRAMS OR DATA.
+ *
+ * Copyright (c) 2017 ISARA Corporation. All Rights Reserved. This file
+ * contains Proprietary information of Isara Corporation. Unauthorized
+ * copying or use of this file via any medium is strictly prohibited.
+ * Written by Anthony Hu, anthony.hu@isara.com; Daniel Van Geest,
+ * daniel.vangeest@isara.com, December, 2017.
+ */
+
+/* Modified.  Was genpkey.c.
+ */
+
+/* Written by Dr Stephen N Henson (steve@openssl.org) for the OpenSSL project
+ * 2006
+ */
+/* ====================================================================
+ * Copyright (c) 2006 The OpenSSL Project.  All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * 3. All advertising materials mentioning features or use of this
+ *    software must display the following acknowledgment:
+ *    "This product includes software developed by the OpenSSL Project
+ *    for use in the OpenSSL Toolkit. (http://www.OpenSSL.org/)"
+ *
+ * 4. The names "OpenSSL Toolkit" and "OpenSSL Project" must not be used to
+ *    endorse or promote products derived from this software without
+ *    prior written permission. For written permission, please contact
+ *    licensing@OpenSSL.org.
+ *
+ * 5. Products derived from this software may not be called "OpenSSL"
+ *    nor may "OpenSSL" appear in their names without prior written
+ *    permission of the OpenSSL Project.
+ *
+ * 6. Redistributions of any form whatsoever must retain the following
+ *    acknowledgment:
+ *    "This product includes software developed by the OpenSSL Project
+ *    for use in the OpenSSL Toolkit (http://www.OpenSSL.org/)"
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE OpenSSL PROJECT ``AS IS'' AND ANY
+ * EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE OpenSSL PROJECT OR
+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
+ * OF THE POSSIBILITY OF SUCH DAMAGE.
+ * ====================================================================
+ *
+ * This product includes cryptographic software written by Eric Young
+ * (eay@cryptsoft.com).  This product includes software written by Tim
+ * Hudson (tjh@cryptsoft.com).
+ *
+ */
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+
+#include "../apps/apps.h"
+#include <openssl/pem.h>
+#include <openssl/err.h>
+#include <openssl/evp.h>
+#include <openssl/engine.h>
+#include <openssl/x509v3.h>
+
+#undef PROG
+#define PROG    x509QSDirectExtend_main
+
+int MAIN(int, char **);
+
+int MAIN(int argc, char **argv)
+{
+    char **args;
+    int badarg = 0;
+    int ret = 1;
+    int self_sign = 0;
+    char *passin = NULL;
+    char *passin_qs = NULL;
+    char *passargin = NULL;
+    char *passargin_qs = NULL;
+
+    ENGINE *e = NULL;
+    EVP_PKEY_CTX *tmpctx = NULL;
+    EVP_PKEY *pkey_qs_priv = NULL;
+    EVP_PKEY *pkey_qs_pub = NULL;
+    EVP_PKEY *classical_privkey = NULL;
+
+    BIO *bio_x509in = NULL;
+    BIO *bio_x509out = NULL;
+    const char *file_priv = NULL;
+    const char *file_qs_pub = NULL;
+    const char *file_qs_priv = NULL;
+
+    X509_ALGOR *algor_for_qssigalg = NULL;
+    X509_EXTENSION *ext_qssigalg = NULL;
+
+    X509 *cert = NULL;
+    ASN1_BIT_STRING *qs_sigval_as_asn1bitstring = NULL;
+
+    int snid = -1;
+    X509_EXTENSION *ext_qssig = NULL;
+
+    X509_PUBKEY *x509_pub_qs = NULL;
+    X509_PUBKEY *x509_sig_qs = NULL;
+    SUBJECT_ALT_PUBLIC_KEY_INFO *sapki = NULL;
+    X509_EXTENSION *ext_sapki = NULL;
+
+    unsigned char *sign_in = NULL;
+    size_t sign_in_size = 0;
+    unsigned char *sign_out = NULL;
+    size_t sign_out_size = 0;
+
+    X509_ALGOR *algo_holder = NULL;
+
+    EVP_MD_CTX mctx;
+
+    const EVP_MD *md_alg = EVP_sha512();
+
+    EVP_MD_CTX_init(&mctx);
+    bio_err = BIO_new_fp(stderr, BIO_NOCLOSE);
+
+    CRYPTO_malloc_debug_init();
+    CRYPTO_set_mem_debug_options(V_CRYPTO_MDEBUG_ALL);
+    CRYPTO_mem_ctrl(CRYPTO_MEM_CHECK_ON);
+
+    ERR_load_crypto_strings();
+    ENGINE_load_dynamic();
+
+    args = argv + 1;
+    while (!badarg && *args && *args[0] == '-') {
+        if (strcmp(*args, "-engine") == 0) {
+            if (!args[1])
+                goto bad;
+            e = setup_engine(bio_err, *(++args), 0);
+            if (e == NULL)
+                goto end;
+        } else if (strcmp(*args, "-x509in") == 0) {
+            if (!args[1])
+                goto bad;
+            bio_x509in = BIO_new_file(*(++args), "rb");
+        } else if (strcmp(*args, "-x509out") == 0) {
+            if (!args[1])
+                goto bad;
+            bio_x509out = BIO_new_file(*(++args), "wb");
+        } else if (strcmp(*args, "-privin") == 0) {
+            if (!args[1])
+                goto bad;
+            file_priv = *(++args);
+        } else if (strcmp(*args, "-pubqs") == 0) {
+            if (!args[1])
+                goto bad;
+            file_qs_pub = *(++args);
+        } else if (strcmp(*args, "-privqs") == 0) {
+            if (!args[1])
+                goto bad;
+            file_qs_priv = *(++args);
+        } else if (strcmp(*args, "-self_sign") == 0) {
+            if (!args[1])
+                goto bad;
+            self_sign = 1;
+        } else if (strcmp(*argv, "-passin") == 0) {
+            if (--argc < 1)
+                goto bad;
+            passargin = *(++argv);
+        } else if (strcmp(*argv, "-passinqs") == 0) {
+            if (--argc < 1)
+                goto bad;
+            passargin_qs = *(++argv);
+        } else {
+            badarg = 1;
+        }
+        args++;
+    }
+
+    if (file_priv == NULL)
+        badarg = 1;
+
+    if (bio_x509in == NULL)
+        badarg = 1;
+
+    if (bio_x509out == NULL)
+        badarg = 1;
+
+    if ((file_qs_pub == NULL) && (self_sign == 0))
+        badarg = 1;
+
+    if ((file_qs_pub != NULL) && (self_sign == 1))
+        badarg = 1;
+
+    if (file_qs_priv == NULL)
+        badarg = 1;
+
+    if (badarg) {
+bad:
+        BIO_printf(bio_err, "Usage: openssl x509QSDirectExtend [options]\n");
+        BIO_printf(bio_err, "where options may be\n");
+        BIO_printf(bio_err,
+                   "-engine e          Use Engine library <e>.\n");
+        BIO_printf(bio_err,
+                   "-x509in file       The X509 certificate in pem format.\n");
+        BIO_printf(bio_err,
+                   "-x509out file      The X509 MPKA certificate in pem format with new ALT extensions.\n");
+        BIO_printf(bio_err,
+                   "-privin file       The private key used to sign the original x509 certificate in pem format.\n");
+        BIO_printf(bio_err,
+                   "-pubqs file        The public QS key.\n");
+        BIO_printf(bio_err,
+                   "-privqs file       The private QS key. \n");
+        BIO_printf(bio_err,
+                   "-self_sign         The public key should be obtained from the private key.\n");
+        BIO_printf(bio_err,
+                   "-passin            The private key password source.\n");
+        BIO_printf(bio_err,
+                   "-passinqs          The private QS key password source.\n");
+        goto end;
+    }
+
+    if (!app_passwd(bio_err, passargin, NULL, &passin, NULL)) {
+        BIO_printf(bio_err, "Error getting password for the private key.\n");
+        goto end;
+    }
+
+    if (!app_passwd(bio_err, passargin_qs, NULL, &passin_qs, NULL)) {
+        BIO_printf(bio_err, "Error getting password for the QS private key.\n");
+        goto end;
+    }
+
+    cert = PEM_read_bio_X509(bio_x509in, NULL, NULL, NULL);
+    if (cert == NULL) {
+        BIO_printf(bio_err, "Bad certificate\n");
+        goto end;
+    }
+
+    classical_privkey = load_key(bio_err, file_priv, FORMAT_PEM, 0, passin, e, "Classical Private Key");
+    if (classical_privkey == NULL) {
+        /* load_key() has already printed an appropriate message. */
+        goto end;
+    }
+
+    pkey_qs_priv = load_key(bio_err, file_qs_priv, FORMAT_PEM, 0, passin_qs, e, "QS Private Key");
+    if (pkey_qs_priv == NULL) {
+        /* load_key() has already printed an appropriate message. */
+        goto end;
+    }
+
+    /* Read the QS Public key to be embedded in the QS req if it was specified.
+     * If not check the private key.
+     */
+    if (file_qs_pub == NULL) {
+        pkey_qs_pub = pkey_qs_priv;
+    } else {
+        pkey_qs_pub = load_pubkey(bio_err, file_qs_pub, FORMAT_PEM, 0, NULL, e, "QS Public Key");
+        if (pkey_qs_pub == NULL) {
+            /* load_pubkey() has already printed an appropriate message. */
+            goto end;
+        }
+    }
+
+    /* Ensure the private key is actually a QS key */
+    if (pkey_qs_priv->type != NID_hss) {
+        BIO_puts(bio_err, "The provided private key is not compatible with a quantum safe algorithm.\n");
+        goto end;
+    }
+
+    /* Ensure the public key is actually a QS key */
+    if (pkey_qs_pub->type != NID_hss) {
+        BIO_puts(bio_err, "The provided public key is not compatable with a quantum safe algorithm.\n");
+        goto end;
+    }
+
+    if (pkey_qs_priv->type == NID_hss) {
+        /* Create a temporary context */
+        tmpctx = EVP_PKEY_CTX_new(pkey_qs_priv, NULL);
+        if (tmpctx == NULL) {
+           BIO_printf(bio_err, "Could not create context.\n");
+           goto end;
+        }
+        /* Send the control string. */
+        if (EVP_PKEY_CTX_ctrl_str(tmpctx, set_hss_private_key_file_ctrl_string, file_qs_priv) <= 0) {
+            BIO_printf(bio_err, "Couldn't set HSS private key file.\n");
+            goto end;
+        }
+
+        /* All the work for the tmpctx is done. */
+        EVP_PKEY_CTX_free(tmpctx);
+        tmpctx = NULL;
+    }
+
+    /* Convert the private key into an x509 public key.  This lets us
+     * get the algorithm identifier of the private key so we can associate
+     * it with the signature.
+     */
+    X509_PUBKEY_set(&x509_sig_qs, pkey_qs_priv);
+
+     /* Convert the pkey in to an x509 public key.  This is the standard way
+      * of doing it for x509 subject public key.
+      */
+    X509_PUBKEY_set(&x509_pub_qs, pkey_qs_pub);
+
+    sapki = SUBJECT_ALT_PUBLIC_KEY_INFO_new();
+    if (sapki == NULL) {
+        BIO_puts(bio_err, "Error converting public key to x509 pubkey\n");
+        goto end;
+    }
+
+    X509_ALGOR_free(sapki->algor);
+    ASN1_BIT_STRING_free(sapki->public_key);
+    sapki->algor = x509_pub_qs->algor;
+    sapki->public_key = x509_pub_qs->public_key;
+
+    /* Create and insert QS signature algorithm as an extension. */
+
+    /* Duplicate the algorithm for the signature. */
+    algor_for_qssigalg = X509_ALGOR_dup(x509_sig_qs->algor);
+    if (algor_for_qssigalg == NULL) {
+        BIO_puts(bio_err, "Error duplicating signature algor.\n");
+        goto end;
+    }
+
+    /* Make sure that the right digest is set. */
+    if (!OBJ_find_sigid_by_algs(&snid, NID_sha512, EVP_PKEY_id(pkey_qs_priv))) {
+        BIO_puts(bio_err, "Error getting NID for digest/signature algorithm combination.\n");
+        goto end;
+    }
+
+    /* Set the Object ID based on the NID in and then convert into an extension. */
+    if (X509_ALGOR_set0(algor_for_qssigalg, OBJ_nid2obj(snid), V_ASN1_UNDEF, 0) == 0) {
+        BIO_puts(bio_err, "Error setting algorithm object ID.\n");
+        goto end;
+    }
+
+    ext_qssigalg = X509V3_EXT_i2d(NID_alt_sigalg, 0, algor_for_qssigalg);
+    if (ext_qssigalg == NULL) {
+        BIO_puts(bio_err, "Error creating signature algorithm extension.\n");
+        goto end;
+    }
+
+    /* Insert QS signature algorithm as an extension. */
+    if (X509_add_ext(cert, ext_qssigalg, -1) == 0) {
+        BIO_puts(bio_err, "Error adding signature algorithm extension.\n");
+        goto end;
+    }
+
+    /* Create and insert QS public key as an extension. */
+    ext_sapki = X509V3_EXT_i2d(NID_subj_alt_pub_key, 0, sapki);
+    sapki->algor = NULL;
+    sapki->public_key = NULL;
+    if (ext_sapki == NULL) {
+        BIO_puts(bio_err, "Error converting x509 pubkey to extension.\n");
+        goto end;
+    }
+
+    if (X509_add_ext(cert, ext_sapki, -1) == 0) {
+        BIO_puts(bio_err, "Error adding public key as extension\n");
+        goto end;
+    }
+
+    /* Sign the cert with the QS private key. */
+    if (EVP_DigestSignInit(&mctx, NULL, md_alg, NULL, pkey_qs_priv) < 1) {
+        BIO_puts(bio_err, "Error doing EVP digest initialization\n");
+        goto end;
+    }
+
+    /* We want to hide the classical algorithm during the QS signing process */
+    algo_holder = cert->cert_info->signature;
+    cert->cert_info->signature = NULL;
+
+    /* Originally we were calling X509_sign_ctx() but this was not a good idea.
+     * We had to stop because of the following code in ASN1_item_sign_ctx() it:
+     *
+     *   if (algor1)
+     *       X509_ALGOR_set0(algor1, OBJ_nid2obj(signid), paramtype, NULL);
+     *   if (algor2)
+     *       X509_ALGOR_set0(algor2, OBJ_nid2obj(signid), paramtype, NULL);
+     *
+     * Those lines were modifying AlgorithmIdentifier in the X509 cert.  That
+     * would change the resulting digest result which is a side effect we would
+     * like to avoid.
+     *
+     * Most of the code below here until we create the signature as an extension
+     * is based off of ASN1_item_sign_ctx() and X509_get0_signature().
+     */
+
+    cert->cert_info->enc.modified = 1;
+
+    sign_in_size = ASN1_item_i2d((ASN1_VALUE *)cert->cert_info, &sign_in, ASN1_ITEM_rptr(X509_CINF));
+
+    sign_out_size = EVP_PKEY_size(pkey_qs_priv);
+    sign_out = OPENSSL_malloc(sign_out_size);
+    if ((sign_in == NULL) || (sign_out == NULL)) {
+        BIO_puts(bio_err, "Memory allocation error for signing input or output.\n");
+        goto end;
+    }
+
+    if (!EVP_DigestSignUpdate(&mctx, sign_in, sign_in_size)
+        || !EVP_DigestSignFinal(&mctx, sign_out, &sign_out_size)) {
+        BIO_puts(bio_err, "EVP digest/sign operation error.\n");
+        goto end;
+    }
+
+    /* Done the QS signing process; bring back the signature algo specifier. */
+    cert->cert_info->signature = algo_holder;
+    algo_holder = NULL;
+
+    qs_sigval_as_asn1bitstring = ASN1_BIT_STRING_new();
+    if (qs_sigval_as_asn1bitstring == NULL) {
+         BIO_puts(bio_err, "ASN1 bit string memory allocation error.\n");
+         goto end;
+    }
+
+    qs_sigval_as_asn1bitstring->flags &= ~(ASN1_STRING_FLAG_BITS_LEFT | 0x07);
+    qs_sigval_as_asn1bitstring->flags |= ASN1_STRING_FLAG_BITS_LEFT;
+    qs_sigval_as_asn1bitstring->data = sign_out;
+    qs_sigval_as_asn1bitstring->length = sign_out_size;
+
+    /* Transferred ownership of the buffer to qs_sigval_as_asn1bitstring. */
+    sign_out = NULL;
+    sign_out_size = 0;
+
+    /* Create QS signature as an extension. */
+    ext_qssig = X509V3_EXT_i2d(NID_alt_sigval, 0, qs_sigval_as_asn1bitstring);
+    if (ext_qssig == NULL) {
+        BIO_puts(bio_err, "Error creating signature extension.\n");
+        goto end;
+    }
+
+    /* Insert QS signature as an extension. */
+    if (X509_add_ext(cert, ext_qssig, -1) == 0) {
+        BIO_puts(bio_err, "Error adding signature extension\n");
+        goto end;
+    }
+
+    /* Re-sign the certificate with the original classical private key. */
+    if (X509_sign(cert, classical_privkey, NULL) == 0) {
+        BIO_puts(bio_err, "Error generating classical signature.\n");
+        goto end;
+    }
+
+    /* write the new signed ciertificate with extensions in it. */
+    if (PEM_write_bio_X509(bio_x509out, cert) == 0) {
+        BIO_puts(bio_err, "Error writing new certificate.\n");
+        goto end;
+    }
+
+    ret = 0;
+
+ end:
+    if (ret != 0)
+        ERR_print_errors(bio_err);
+
+    EVP_MD_CTX_cleanup(&mctx);
+    if (tmpctx)
+        EVP_PKEY_CTX_free(tmpctx);
+    if (bio_x509in)
+        BIO_free_all(bio_x509in);
+    if (bio_x509out)
+        BIO_free_all(bio_x509out);
+    if (cert)
+        X509_free(cert);
+    if (pkey_qs_pub == pkey_qs_priv)
+        pkey_qs_pub = NULL;
+    if (pkey_qs_pub)
+        EVP_PKEY_free(pkey_qs_pub);
+    if (pkey_qs_priv)
+        EVP_PKEY_free(pkey_qs_priv);
+    if (classical_privkey)
+        EVP_PKEY_free(classical_privkey);
+    if (x509_pub_qs)
+        X509_PUBKEY_free(x509_pub_qs);
+    if (x509_sig_qs)
+        X509_PUBKEY_free(x509_sig_qs);
+    if (sapki)
+        SUBJECT_ALT_PUBLIC_KEY_INFO_free(sapki);
+    if (algor_for_qssigalg)
+        X509_ALGOR_free(algor_for_qssigalg);
+    if (algo_holder)
+        X509_ALGOR_free(algo_holder);
+
+    OPENSSL_free(sign_out);
+    OPENSSL_free(sign_in);
+    if (qs_sigval_as_asn1bitstring)
+        ASN1_BIT_STRING_free(qs_sigval_as_asn1bitstring);
+    if (ext_sapki)
+        X509_EXTENSION_free(ext_sapki);
+    if (ext_qssig)
+        X509_EXTENSION_free(ext_qssig);
+    if (ext_qssigalg)
+        X509_EXTENSION_free(ext_qssigalg);
+
+    if (passargin && passin)
+        OPENSSL_free(passin);
+    if (passargin_qs && passin_qs)
+        OPENSSL_free(passin_qs);
+    release_engine(e);
+    OBJ_cleanup();
+    apps_shutdown();
+    OPENSSL_EXIT(ret);
+}
diff --git a/apps/QSExtend/x509QSExtend.c b/apps/QSExtend/x509QSExtend.c
new file mode 100644
index 0000000..5dc17e9
--- /dev/null
+++ b/apps/QSExtend/x509QSExtend.c
@@ -0,0 +1,857 @@
+/** @file x509QSExtend.c Load QS CSR and traditional X.509 certificate and use them to create a multiple public key algorithm certificate.
+ *
+ * Isara Corporation Quantum Safe EST Proprietary Software License
+ * Statement
+ *
+ * LICENSE AGREEMENT: The Product(s) that reference this license include
+ * embedded proprietary software and software “plug-ins” in source code or
+ * object code or both (the “Software”) and accompanying materials (the
+ * “Documentation”) that are subject to the license terms and restrictions
+ * described below (the “License"). If you do not agree to the License
+ * terms, do not use the Product, notify Isara Corporation (“Isara”) by
+ * electronic mail at sales@isara.com and erase any copies of the Product
+ * in your possession. If you are entering into this License on behalf of
+ * a company or other legal entity, you represent that you have the right
+ * to bind that entity to all terms, and “you” refers both to you
+ * personally and such entity.
+ *
+ * USE AND DISTRIBUTION: You may use the Software only in the form and in
+ * the Product(s) delivered to you for the purposes of integration,
+ * development and testing with your own products and/or as part of a
+ * monitoring and/or control group beta test with third parties that agree
+ * in writing to be bound by the terms of this License.
+ *
+ * ADDITIONAL RESTRICTIONS: You shall not use, modify, reproduce, reverse
+ * engineer, disassemble, decompile or otherwise attempt to derive source
+ * code from the Software (except to the extent that such limitations may
+ * not be prohibited by law), sublicense, or distribute the Software or
+ * Documentation other than as permitted by this License. You shall not
+ * remove any proprietary notices, labels or marks on the Product(s) “ZIP
+ * file”, Software or Documentation. No license is granted to use or
+ * reproduce any Isara trademarks.
+ *
+ * OWNERSHIP AND NOTICE: Except for the limited rights granted above,
+ * Isara and its suppliers retain all right, title and interest in and to
+ * the Software and Documentation, including copyrights, patents, trade
+ * secrets and other proprietary rights. Certain components of the
+ * Software that are subject to open source and third party licenses, the
+ * terms and conditions of which can found at https://github.com/cisco and
+ * select the applicable hash-sigs or libest license filed on the Github
+ * repository. If you require additional guidance, notify sales@isara.com
+ * for assistance. As a condition of the License, you agree to comply with
+ * all of the foregoing open source and third party license terms. Unless
+ * required by applicable law, such components are provided on an ‘AS IS’
+ * BASIS, WITHOUT EXPRESS OR IMPLIED WARRANTIES OR CONDITIONS OF ANY KIND.
+ *
+ * WARRANTY DISCLAIMER: THE SOFTWARE AND DOCUMENTATION ARE PROVIDED TO YOU
+ * "AS IS", AND YOU ASSUME THE ENTIRE RISK OF THEIR USE. ISARA AND ITS
+ * SUPPLIERS MAKES NO WARRANTIES OR CONDITIONS, EXPRESS, IMPLIED,
+ * STATUTORY OR IN ANY COMMUNICATION WITH YOU, AND ISARA CORPORATION
+ * EXPRESSLY DISCLAIMS ANY IMPLIED WARRANTIES OF MERCHANTABILITY, FITNESS
+ * FOR A PARTICULAR PURPOSE OR NONINFRINGEMENT WITH RESPECT TO THE
+ * SOFTWARE (INCLUDING ANY MODIFICATIONS MADE THERETO BY ANY PERSON
+ * WHETHER OR NOT AN EMPLOYEE OR CONTRACTOR OF ISARA) OR DOCUMENTATION
+ * PROVIDED TO YOU. ISARA EMPLOYEES AND OTHER PERSONNEL ARE NOT AUTHORIZED
+ * TO MAKE ANY WARRANTY THAT IS INCONSISTENT WITH THIS DISCLAIMER.
+ *
+ * LIMITATION OF LIABILITY: IN NO EVENT WILL ISARA OR ITS SUPPLIERS AND
+ * SUPPLIERS BE LIABLE FOR LOSS OF DATA, LOST PROFITS, COST OF COVER, OR
+ * OTHER SPECIAL, INCIDENTAL, PUNITIVE, CONSEQUENTIAL, OR INDIRECT DAMAGES
+ * ARISING FROM USE OF THE SOFTWARE OR DOCUMENTATION, HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, AND REGARDLESS OF WHETHER ISARA OR ITS
+ * SUPPLIERS HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  ISARA
+ * AND ITS SUPPLIERS BEAR NO LIABILITY FOR ANY PROGRAMS OR DATA STORED IN
+ * OR USED WITH THIS PRODUCT, INCLUDING THE COST OF RECOVERING SUCH
+ * PROGRAMS OR DATA.
+ *
+ * Copyright (c) 2017 ISARA Corporation. All Rights Reserved. This file
+ * contains Proprietary information of Isara Corporation. Unauthorized
+ * copying or use of this file via any medium is strictly prohibited.
+ * Written by Anthony Hu, anthony.hu@isara.com; Daniel Van Geest,
+ * daniel.vangeest@isara.com, December, 2017.
+ */
+
+/* Modified.  Was genpkey.c.
+ */
+
+/* Written by Dr Stephen N Henson (steve@openssl.org) for the OpenSSL project
+ * 2006
+ */
+/* ====================================================================
+ * Copyright (c) 2006 The OpenSSL Project.  All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * 3. All advertising materials mentioning features or use of this
+ *    software must display the following acknowledgment:
+ *    "This product includes software developed by the OpenSSL Project
+ *    for use in the OpenSSL Toolkit. (http://www.OpenSSL.org/)"
+ *
+ * 4. The names "OpenSSL Toolkit" and "OpenSSL Project" must not be used to
+ *    endorse or promote products derived from this software without
+ *    prior written permission. For written permission, please contact
+ *    licensing@OpenSSL.org.
+ *
+ * 5. Products derived from this software may not be called "OpenSSL"
+ *    nor may "OpenSSL" appear in their names without prior written
+ *    permission of the OpenSSL Project.
+ *
+ * 6. Redistributions of any form whatsoever must retain the following
+ *    acknowledgment:
+ *    "This product includes software developed by the OpenSSL Project
+ *    for use in the OpenSSL Toolkit (http://www.OpenSSL.org/)"
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE OpenSSL PROJECT ``AS IS'' AND ANY
+ * EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE OpenSSL PROJECT OR
+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
+ * OF THE POSSIBILITY OF SUCH DAMAGE.
+ * ====================================================================
+ *
+ * This product includes cryptographic software written by Eric Young
+ * (eay@cryptsoft.com).  This product includes software written by Tim
+ * Hudson (tjh@cryptsoft.com).
+ *
+ */
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+
+#include "../apps/apps.h"
+#include <openssl/asn1_mac.h>
+#include <openssl/pem.h>
+#include <openssl/err.h>
+#include <openssl/evp.h>
+#include <openssl/engine.h>
+#include <openssl/x509v3.h>
+
+SUBJECT_ALT_PUBLIC_KEY_INFO *get_SAPKI_from_ATTRIBUTE(X509_ATTRIBUTE *attr) {
+
+    ASN1_TYPE *so = NULL;
+    ASN1_OBJECT *o = OBJ_nid2obj(NID_subj_alt_pub_key);
+    ASN1_const_CTX c;
+    ASN1_STRING *s = NULL;
+    long length = 0;
+    SUBJECT_ALT_PUBLIC_KEY_INFO *sapki = NULL;
+
+    if (OBJ_cmp(attr->object, o) != 0) {
+        fprintf (stderr, "Unexpected Object ID\n") ;
+        goto err;
+    }
+
+    if (!attr->single && sk_ASN1_TYPE_num(attr->value.set)) {
+        so = sk_ASN1_TYPE_value(attr->value.set, 0);
+    } else {
+        fprintf (stderr, "Attribute format error.\n") ;
+        goto err;
+    }
+
+    if ((so == NULL) || (so->type != V_ASN1_SEQUENCE)) {
+        fprintf (stderr, "Attribute ASN.1 format error.\n") ;
+        goto err;
+    }
+
+    s = so->value.sequence;
+    c.p = ASN1_STRING_data(s);
+    length = ASN1_STRING_length(s);
+    c.max = c.p + length;
+    if (!asn1_GetSequence(&c, &length)) {
+        fprintf (stderr, "Attribute internal ASN.1 format error.\n") ;
+        goto err;
+    }
+
+    c.q = c.p;
+    sapki = d2i_SUBJECT_ALT_PUBLIC_KEY_INFO(NULL, &c.p, c.slen);
+    if (sapki == NULL) {
+        fprintf (stderr, "Invalid ALT public key attribute.\n") ;
+        goto err;
+    }
+    c.slen -= (c.p - c.q);
+    c.q = c.p;
+
+    if (!asn1_const_Finish(&c)) {
+        fprintf (stderr, "Attribute had junk after the ASN.1 data.\n") ;
+        goto err;
+    }
+
+    return sapki;
+
+err:
+    SUBJECT_ALT_PUBLIC_KEY_INFO_free(sapki);
+    return NULL;
+}
+
+ASN1_BIT_STRING *get_ALTSIG_from_ATTRIBUTE(X509_ATTRIBUTE *attr) {
+
+    ASN1_TYPE *so = NULL;
+    ASN1_OBJECT *o = OBJ_nid2obj(NID_alt_sigval);
+    ASN1_BIT_STRING *altsig = NULL;
+
+    if (OBJ_cmp(attr->object, o) != 0) {
+        fprintf (stderr, "Unexpected Object ID\n") ;
+        goto err;
+    }
+
+    if (!attr->single && sk_ASN1_TYPE_num(attr->value.set)) {
+        so = sk_ASN1_TYPE_value(attr->value.set, 0);
+    } else {
+        fprintf (stderr, "Attribute format error.\n") ;
+        goto err;
+    }
+
+    if ((so == NULL) || (so->type != V_ASN1_BIT_STRING)) {
+        fprintf (stderr, "Attribute ASN.1 format error.\n") ;
+        goto err;
+    }
+
+    altsig = X509_ATTRIBUTE_get0_data(attr, 0, V_ASN1_BIT_STRING, NULL);
+    if (altsig == NULL) {
+        fprintf (stderr, "Couldn't get ASN1 data from attribute.\n") ;
+        goto err;
+    }
+
+    return altsig;
+
+err:
+    return NULL;
+}
+
+X509_ALGOR *get_ALTSIGALG_from_ATTRIBUTE(X509_ATTRIBUTE *attr) {
+
+    ASN1_TYPE *so = NULL;
+    ASN1_OBJECT *o = OBJ_nid2obj(NID_alt_sigalg);
+    X509_ALGOR *altsigalg = NULL;
+    ASN1_STRING *s = NULL;
+    const unsigned char *data = NULL;
+    long length = 0;
+
+    if (OBJ_cmp(attr->object, o) != 0) {
+        fprintf (stderr, "Unexpected Object ID\n") ;
+        goto err;
+    }
+
+    if (!attr->single && sk_ASN1_TYPE_num(attr->value.set)) {
+        so = sk_ASN1_TYPE_value(attr->value.set, 0);
+    } else {
+        fprintf (stderr, "Attribute format error.\n") ;
+        goto err;
+    }
+
+    if ((so == NULL) || (so->type != V_ASN1_SEQUENCE)) {
+        fprintf (stderr, "Attribute ASN.1 format error.\n") ;
+        goto err;
+    }
+
+    s = so->value.sequence;
+    data = ASN1_STRING_data(s);
+    length = ASN1_STRING_length(s);
+    altsigalg = d2i_X509_ALGOR(NULL, &data, length);
+    return altsigalg;
+
+err:
+    return NULL;
+}
+
+#undef PROG
+#define PROG    x509QSExtend_main
+
+int MAIN(int, char **);
+
+int MAIN(int argc, char **argv)
+{
+    char **args;
+    int badarg = 0;
+    int ret = 1;
+    char *passin = NULL;
+    char *passin_qs = NULL;
+    char *passargin = NULL;
+    char *passargin_qs = NULL;
+
+    ENGINE *e = NULL;
+    EVP_PKEY_CTX *tmpctx = NULL;
+    EVP_PKEY *pkey_qs_priv = NULL;
+    EVP_PKEY *pkey_qs_pub = NULL;
+    EVP_PKEY *classical_privkey = NULL;
+    X509_REQ *req = NULL;
+    X509_REQ *tmpreq = NULL;
+    EVP_PKEY *tmppkey = NULL;
+
+    BIO *bio_x509in = NULL;
+    BIO *bio_x509out = NULL;
+    BIO *bio_req = NULL;
+    const char *file_priv = NULL;
+    const char *file_qs_priv = NULL;
+
+    X509_ALGOR *algor_for_qssigalg = NULL;
+    X509_EXTENSION *ext_qssigalg = NULL;
+
+    X509 *cert = NULL;
+    ASN1_BIT_STRING *qs_sigval_as_asn1bitstring = NULL;
+
+    int alg_nid = -1;
+    int snid = -1;
+    X509_EXTENSION *ext_qssig = NULL;
+    X509_ALGOR *qssig_algor = NULL;
+
+    X509_PUBKEY *x509_pub_qs = NULL;
+    X509_PUBKEY *x509_sig_qs = NULL;
+    SUBJECT_ALT_PUBLIC_KEY_INFO *sapki_in = NULL;
+    SUBJECT_ALT_PUBLIC_KEY_INFO *sapki_out = NULL;
+    X509_EXTENSION *ext_sapki = NULL;
+
+    unsigned char *sign_in = NULL;
+    size_t sign_in_size = 0;
+    unsigned char *sign_out = NULL;
+    size_t sign_out_size = 0;
+
+    X509_ATTRIBUTE *qs_pub_key_attr = NULL;
+    int qs_pub_key_ind = -1;
+
+    X509_ATTRIBUTE *qs_sigval_attr = NULL;
+    int qs_sigval_ind = -1;
+    X509_ALGOR *algo_holder = NULL;
+
+    X509_ATTRIBUTE *qs_sigalg_attr = NULL;
+    int qs_sigalg_ind = -1;
+
+    EVP_MD_CTX mctx;
+    STACK_OF(X509_EXTENSION) *req_exts = NULL;
+
+    ASN1_BIT_STRING *req_qssig = NULL;
+    X509_ALGOR *req_qssigalg = NULL;
+
+    const EVP_MD *md_alg = EVP_sha512();
+
+    EVP_MD_CTX_init(&mctx);
+    bio_err = BIO_new_fp(stderr, BIO_NOCLOSE);
+
+    CRYPTO_malloc_debug_init();
+    CRYPTO_set_mem_debug_options(V_CRYPTO_MDEBUG_ALL);
+    CRYPTO_mem_ctrl(CRYPTO_MEM_CHECK_ON);
+
+    ERR_load_crypto_strings();
+    ENGINE_load_dynamic();
+
+    args = argv + 1;
+    while (!badarg && *args && *args[0] == '-') {
+        if (strcmp(*args, "-engine") == 0) {
+            if (!args[1])
+                goto bad;
+            e = setup_engine(bio_err, *(++args), 0);
+            if (e == NULL)
+                goto end;
+        } else if (strcmp(*args, "-x509in") == 0) {
+            if (!args[1])
+                goto bad;
+            bio_x509in = BIO_new_file(*(++args), "rb");
+        } else if (strcmp(*args, "-x509out") == 0) {
+            if (!args[1])
+                goto bad;
+            bio_x509out = BIO_new_file(*(++args), "wb");
+        } else if (strcmp(*args, "-privin") == 0) {
+            if (!args[1])
+                goto bad;
+            file_priv = *(++args);
+        } else if (strcmp(*args, "-reqin") == 0) {
+            if (!args[1])
+                goto bad;
+            bio_req = BIO_new_file(*(++args), "rb");
+        } else if (strcmp(*args, "-privqs") == 0) {
+            if (!args[1])
+                goto bad;
+            file_qs_priv = *(++args);
+        } else if (strcmp(*argv, "-passin") == 0) {
+            if (--argc < 1)
+                goto bad;
+            passargin = *(++argv);
+        } else if (strcmp(*argv, "-passinqs") == 0) {
+            if (--argc < 1)
+                goto bad;
+            passargin_qs = *(++argv);
+        } else {
+            badarg = 1;
+        }
+        args++;
+    }
+
+    if (file_priv == NULL)
+        badarg = 1;
+
+    if (bio_x509in == NULL)
+        badarg = 1;
+
+    if (bio_x509out == NULL)
+        badarg = 1;
+
+    if (bio_req == NULL)
+        badarg = 1;
+
+    if (file_qs_priv == NULL)
+        badarg = 1;
+
+    if (badarg) {
+bad:
+        BIO_printf(bio_err, "Usage: openssl x509QSExtend [options]\n");
+        BIO_printf(bio_err, "where options may be\n");
+        BIO_printf(bio_err,
+                   "-engine e          Use Engine library <e>.\n");
+        BIO_printf(bio_err,
+                   "-x509in file       The X509 certificate in pem format.\n");
+        BIO_printf(bio_err,
+                   "-x509out file      The X509 MPKA certificate in pem format with new ALT extensions.\n");
+        BIO_printf(bio_err,
+                   "-privin file       The private key used to sign the original x509 certificate in pem format.\n");
+        BIO_printf(bio_err,
+                   "-reqin file        The certificate signing request containing the ALT public key extension.\n");
+        BIO_printf(bio_err,
+                   "-privqs file       The private QS key. \n");
+        BIO_printf(bio_err,
+                   "-passin            The private key password source.\n");
+        BIO_printf(bio_err,
+                   "-passinqs          The private QS key password source.\n");
+        goto end;
+    }
+
+    if (!app_passwd(bio_err, passargin, NULL, &passin, NULL)) {
+        BIO_printf(bio_err, "Error getting password for the private key.\n");
+        goto end;
+    }
+
+    if (!app_passwd(bio_err, passargin_qs, NULL, &passin_qs, NULL)) {
+        BIO_printf(bio_err, "Error getting password for the QS private key.\n");
+        goto end;
+    }
+
+    /* Read in the req which contains the public key */
+    req = PEM_read_bio_X509_REQ(bio_req, NULL, NULL, NULL);
+    if (req == NULL) {
+        BIO_printf(bio_err, "Bad certificate signing request.\n");
+        goto end;
+    }
+
+    /* Get the ALT public key attribute. */
+    qs_pub_key_ind = X509_REQ_get_attr_by_NID(req, NID_subj_alt_pub_key, -1);
+    if (qs_pub_key_ind < 0) {
+        fprintf(stderr, "Error finding the req's ALT public key attribute.\n");
+        goto end;
+    }
+
+    qs_pub_key_attr = X509_REQ_get_attr(req, qs_pub_key_ind);
+    if (qs_pub_key_attr == NULL) {
+        fprintf(stderr, "Error getting the req's ALT public key attribute.\n");
+        goto end;
+    }
+
+    sapki_in = get_SAPKI_from_ATTRIBUTE(qs_pub_key_attr);
+    if (sapki_in == NULL) {
+        fprintf(stderr, "Error converting the req's ALT public key attribute into ASN.1.\n");
+        goto end;
+    }
+
+    /* Convert the ALT public key attribute to a pkey. */
+    x509_pub_qs = X509_PUBKEY_new();
+    if (x509_pub_qs == NULL) {
+        fprintf(stderr, "Memory allocation error.\n");
+        goto end;
+    }
+
+    X509_ALGOR_free(x509_pub_qs->algor);
+    ASN1_BIT_STRING_free(x509_pub_qs->public_key);
+
+    x509_pub_qs->algor = sapki_in->algor;
+    x509_pub_qs->public_key = sapki_in->public_key;
+    x509_pub_qs->pkey = NULL;
+
+    pkey_qs_pub = X509_PUBKEY_get(x509_pub_qs);
+
+    x509_pub_qs->algor = NULL;
+    x509_pub_qs->public_key = NULL;
+    X509_PUBKEY_free(x509_pub_qs);
+    x509_pub_qs = NULL;
+
+    if (pkey_qs_pub == NULL) {
+        BIO_printf(bio_err, "Bad QS public key.\n");
+        goto end;
+    }
+
+    /* Get the ALT signature attribute. */
+    qs_sigval_ind = X509_REQ_get_attr_by_NID(req, NID_alt_sigval, -1);
+    if (qs_sigval_ind < 0) {
+        fprintf(stderr, "Error finding the req's ALT signature attribute.\n");
+        goto end;
+    }
+
+    qs_sigval_attr = X509_REQ_get_attr(req, qs_sigval_ind);
+    if (qs_sigval_attr == NULL) {
+        fprintf(stderr, "Error getting the req's ALT signature attribute.\n");
+        goto end;
+    }
+
+    /* Remove the ALT signature attribute to make it look the same as when it
+     * was signed.
+     */
+    if (X509_REQ_delete_attr(req, qs_sigval_ind) == 0) {
+        fprintf(stderr, "Error getting the req's ALT signature attribute.\n");
+        goto end;
+    }
+
+    req_qssig = get_ALTSIG_from_ATTRIBUTE(qs_sigval_attr);
+    if (req_qssig == NULL) {
+        fprintf(stderr, "Error converting the req's ALT signature attribute into ASN.1.\n");
+        goto end;
+    }
+
+    /* Get the ALT signature algorithm attribute. */
+    qs_sigalg_ind = X509_REQ_get_attr_by_NID(req, NID_alt_sigalg, -1);
+    if (qs_sigalg_ind < 0) {
+        fprintf(stderr, "Error finding the req's ALT signature algorithm attribute index.\n");
+        goto end;
+    }
+
+    qs_sigalg_attr = X509_REQ_get_attr(req, qs_sigalg_ind);
+    if (qs_sigalg_attr == NULL) {
+        fprintf(stderr, "Error getting the req's ALT signature algorithm attribute.\n");
+        goto end;
+    }
+
+    req_qssigalg = get_ALTSIGALG_from_ATTRIBUTE(qs_sigalg_attr);
+    if (req_qssigalg == NULL) {
+        fprintf(stderr, "Error converting the req's ALT signature attribute into ASN.1.\n");
+        goto end;
+    }
+
+    /* Ensure that the signature algorithm of the sig and the alogrithm of the public key
+     * match. We can't use X509_ALGOR_cmp() because the OIDs don't match. The
+     * signature OID includes information about the digest. We don't worry about digest
+     * and parameter mismatch as the actual verification will catch that.
+     */
+    if (OBJ_find_sigid_algs(OBJ_obj2nid(req_qssigalg->algorithm), NULL, &alg_nid) == 0) {
+        fprintf(stderr, "Couldn't get the algorithm ID from the ALT signature.\n");
+        goto end;
+    }
+
+    if (alg_nid != OBJ_obj2nid(sapki_in->algor->algorithm)) {
+        fprintf(stderr, "Issuer public key algorithm does not match signature algorithm\n");
+        fprintf(stderr, "Issuer: %s\n", OBJ_nid2ln(OBJ_obj2nid(sapki_in->algor->algorithm)));
+        fprintf(stderr, "Current: %s\n", OBJ_nid2ln(OBJ_obj2nid(req_qssigalg->algorithm)));
+        goto end;
+    }
+
+    req->req_info->enc.modified = 1;
+
+    if (ASN1_item_verify(ASN1_ITEM_rptr(X509_REQ_INFO), req_qssigalg,
+                         req_qssig, req->req_info, pkey_qs_pub) <= 0) {
+        printf("QS verification FAILED!\n");
+        goto end;
+    }
+
+    /* We do not do verification of the classical signature as we assume it was
+     * done during the creation of the classical chain. Now that the req is
+     * verified, we can construct the cert.
+     */
+
+    /* Read in the classical cert. */
+    cert = PEM_read_bio_X509(bio_x509in, NULL, NULL, NULL);
+    if (cert == NULL) {
+        BIO_printf(bio_err, "Bad certificate\n");
+        goto end;
+    }
+
+    /* Read in the classical private key that will be used to re-sign
+     * this cert.
+     */
+    classical_privkey = load_key(bio_err, file_priv, FORMAT_PEM, 0, passin, e, "Classical Private Key");
+    if (classical_privkey == NULL) {
+        /* load_key() has already printed an appropriate message. */
+        goto end;
+    }
+
+    /* Read in the QS private key that will be used to create the QS
+     * signature.
+     */
+    pkey_qs_priv = load_key(bio_err, file_qs_priv, FORMAT_PEM, 0, passin_qs, e, "QS Private Key");
+    if (pkey_qs_priv == NULL) {
+        /* load_key() has already printed an appropriate message. */
+        goto end;
+    }
+
+    /* Ensure the private key is actually a QS key */
+    if (pkey_qs_priv->type != NID_hss) {
+        BIO_puts(bio_err, "The provided private key is not compatible with a quantum safe algorithm.\n");
+        goto end;
+    }
+
+    if (pkey_qs_priv->type == NID_hss) {
+        /* Create a temporary context */
+        tmpctx = EVP_PKEY_CTX_new(pkey_qs_priv, NULL);
+        if (tmpctx == NULL) {
+           BIO_printf(bio_err, "Could not create context.\n");
+           goto end;
+        }
+        /* Send the control string. */
+        if (EVP_PKEY_CTX_ctrl_str(tmpctx, set_hss_private_key_file_ctrl_string, file_qs_priv) <= 0) {
+            BIO_printf(bio_err, "Couldn't set HSS private key file.\n");
+            goto end;
+        }
+
+        /* All the work for the tmpctx is done. */
+        EVP_PKEY_CTX_free(tmpctx);
+        tmpctx = NULL;
+    }
+
+    /* Make sure the public key is actually QS. */
+    if (pkey_qs_pub->type != NID_hss) {
+        BIO_puts(bio_err, "The provided public key is not compatible with a quantum safe algorithm.\n");
+        goto end;
+    }
+
+    /* Convert the private key into an x509 public key.  This lets us
+     * get the algorithm identifier of the private key so we can associate
+     * it with the signature.
+     */
+    X509_PUBKEY_set(&x509_sig_qs, pkey_qs_priv);
+
+    /* Convert the pkey into an x509 format public key. */
+    X509_PUBKEY_set(&x509_pub_qs, pkey_qs_pub);
+
+    sapki_out = SUBJECT_ALT_PUBLIC_KEY_INFO_new();
+    X509_ALGOR_free(sapki_out->algor);
+    ASN1_BIT_STRING_free(sapki_out->public_key);
+    sapki_out->algor = x509_pub_qs->algor;
+    sapki_out->public_key = x509_pub_qs->public_key;
+
+    /* The next few blocks of code create and insert the QS signature algorithm
+     * as an extension.
+     */
+
+    /* Duplicate the algorithm for the signature. */
+    algor_for_qssigalg = X509_ALGOR_dup(x509_sig_qs->algor);
+    if (algor_for_qssigalg == NULL) {
+        BIO_puts(bio_err, "Error duplicating signature algor.\n");
+        goto end;
+    }
+
+    /* Make sure that the right digest is set. */
+    if (!OBJ_find_sigid_by_algs(&snid, NID_sha512, EVP_PKEY_id(pkey_qs_priv))) {
+        BIO_puts(bio_err, "Error getting NID for digest/signature algorithm combination.\n");
+        goto end;
+    }
+
+    /* Set the Object ID based on the NID and then convert into an extension. */
+    if (X509_ALGOR_set0(algor_for_qssigalg, OBJ_nid2obj(snid), V_ASN1_UNDEF, 0) == 0) {
+        BIO_puts(bio_err, "Error setting algorithm object ID.\n");
+        goto end;
+    }
+
+    ext_qssigalg = X509V3_EXT_i2d(NID_alt_sigalg, 0, algor_for_qssigalg);
+    if (ext_qssigalg == NULL) {
+        BIO_puts(bio_err, "Error creating signature algorithm extension.\n");
+        goto end;
+    }
+
+    /* Insert QS signature algorithm as an extension. */
+    if (X509_add_ext(cert, ext_qssigalg, -1) == 0) {
+        BIO_puts(bio_err, "Error adding signature algorithm extension.\n");
+        goto end;
+    }
+
+    /* Create and insert QS public key as an extension. */
+    ext_sapki = X509V3_EXT_i2d(NID_subj_alt_pub_key, 0, sapki_out);
+    sapki_out->algor = NULL;
+    sapki_out->public_key = NULL;
+    if (ext_sapki == NULL) {
+        BIO_puts(bio_err, "Error converting x509 pubkey to extension.\n");
+        goto end;
+    }
+
+    /* Add the ALT public key extension to the cert. */
+    if (X509_add_ext(cert, ext_sapki, -1) == 0) {
+        BIO_puts(bio_err, "Error adding public key as extension\n");
+        goto end;
+    }
+
+    /* Sign the cert with the QS private key. */
+    if (EVP_DigestSignInit(&mctx, NULL, md_alg, NULL, pkey_qs_priv) < 1) {
+        BIO_puts(bio_err, "Error doing EVP digest initialization\n");
+        goto end;
+    }
+
+    /* We want to hide the classical algorithm during the QS signing process */
+    algo_holder = cert->cert_info->signature;
+    cert->cert_info->signature = NULL;
+
+    /* Originally we were calling X509_sign_ctx() but this was not a good idea.
+     * We had to stop because of the following code in ASN1_item_sign_ctx() it:
+     *
+     *   if (algor1)
+     *       X509_ALGOR_set0(algor1, OBJ_nid2obj(signid), paramtype, NULL);
+     *   if (algor2)
+     *       X509_ALGOR_set0(algor2, OBJ_nid2obj(signid), paramtype, NULL);
+     *
+     * Those lines were modifying AlgorithmIdentifier in the X509 cert.  That
+     * would change the resulting digest result which is a side effect we want
+     * to avoid.
+     *
+     * Most of the code below here until we create the signature as an extension
+     * is based on ASN1_item_sign_ctx() and X509_get0_signature().
+     */
+
+    cert->cert_info->enc.modified = 1;
+
+    sign_in_size = ASN1_item_i2d((ASN1_VALUE *)cert->cert_info, &sign_in, ASN1_ITEM_rptr(X509_CINF));
+
+    sign_out_size = EVP_PKEY_size(pkey_qs_priv);
+    sign_out = OPENSSL_malloc(sign_out_size);
+    if ((sign_in == NULL) || (sign_out == NULL)) {
+        BIO_puts(bio_err, "Memory allocation error for signing input or output.\n");
+        goto end;
+    }
+
+    if (!EVP_DigestSignUpdate(&mctx, sign_in, sign_in_size)
+        || !EVP_DigestSignFinal(&mctx, sign_out, &sign_out_size)) {
+        BIO_puts(bio_err, "EVP digest/sign operation error.\n");
+        goto end;
+    }
+
+    /* Done the QS signing process; bring back the signature algo specifier. */
+    cert->cert_info->signature = algo_holder;
+    algo_holder = NULL;
+
+    qs_sigval_as_asn1bitstring = ASN1_BIT_STRING_new();
+    if (qs_sigval_as_asn1bitstring == NULL) {
+         BIO_puts(bio_err, "ASN1 bit string memory allocation error.\n");
+         goto end;
+    }
+
+    qs_sigval_as_asn1bitstring->flags &= ~(ASN1_STRING_FLAG_BITS_LEFT | 0x07);
+    qs_sigval_as_asn1bitstring->flags |= ASN1_STRING_FLAG_BITS_LEFT;
+    qs_sigval_as_asn1bitstring->data = sign_out;
+    qs_sigval_as_asn1bitstring->length = sign_out_size;
+
+    /* Transferred ownership of the buffer to qs_sigval_as_asn1bitstring. */
+    sign_out = NULL;
+    sign_out_size = 0;
+
+    /* Create QS signature as an extension. */
+    ext_qssig = X509V3_EXT_i2d(NID_alt_sigval, 0, qs_sigval_as_asn1bitstring);
+    if (ext_qssig == NULL) {
+        BIO_puts(bio_err, "Error creating signature extension.\n");
+        goto end;
+    }
+
+    /* Insert QS signature as an extension. */
+    if (X509_add_ext(cert, ext_qssig, -1) == 0) {
+        BIO_puts(bio_err, "Error adding signature extension\n");
+        goto end;
+    }
+
+    /* Re-sign the certificate with the original classical private key. */
+    if (X509_sign(cert, classical_privkey, NULL) == 0) {
+        BIO_puts(bio_err, "Error generating classical signature.\n");
+        goto end;
+    }
+
+    /* write the new signed certificate with extensions in it. */
+    if (PEM_write_bio_X509(bio_x509out, cert) == 0) {
+        BIO_puts(bio_err, "Error writing new certificate.\n");
+        goto end;
+    }
+
+    ret = 0;
+
+ end:
+    if (ret != 0)
+        ERR_print_errors(bio_err);
+
+    EVP_MD_CTX_cleanup(&mctx);
+    if (tmpctx)
+        EVP_PKEY_CTX_free(tmpctx);
+    if (tmpreq)
+        X509_REQ_free(tmpreq);
+    if (tmppkey)
+        EVP_PKEY_free(tmppkey);
+    if (bio_req)
+        BIO_free_all(bio_req);
+    if (bio_x509in)
+        BIO_free_all(bio_x509in);
+    if (bio_x509out)
+        BIO_free_all(bio_x509out);
+    if (cert)
+        X509_free(cert);
+    if (pkey_qs_pub)
+        EVP_PKEY_free(pkey_qs_pub);
+    if (pkey_qs_priv)
+        EVP_PKEY_free(pkey_qs_priv);
+    if (classical_privkey)
+        EVP_PKEY_free(classical_privkey);
+    if (req)
+        X509_REQ_free(req);
+
+    if (sapki_in)
+        SUBJECT_ALT_PUBLIC_KEY_INFO_free(sapki_in);
+    if (sapki_out)
+        SUBJECT_ALT_PUBLIC_KEY_INFO_free(sapki_out);
+    if (algor_for_qssigalg)
+        X509_ALGOR_free(algor_for_qssigalg);
+    if (req_qssigalg)
+        X509_ALGOR_free(req_qssigalg);
+    if (x509_pub_qs)
+        X509_PUBKEY_free(x509_pub_qs);
+    if (x509_sig_qs)
+        X509_PUBKEY_free(x509_sig_qs);
+    if (qssig_algor)
+        X509_ALGOR_free(qssig_algor);
+    if (algo_holder)
+        X509_ALGOR_free(algo_holder);
+
+    /* We used OPENSSL_malloc() to allocate this so we do not use the custom
+     * free functions to free it.
+     */
+    OPENSSL_free(sign_out);
+    OPENSSL_free(sign_in);
+
+    if (qs_sigval_as_asn1bitstring)
+        ASN1_BIT_STRING_free(qs_sigval_as_asn1bitstring);
+    if (ext_sapki)
+        X509_EXTENSION_free(ext_sapki);
+    if (ext_qssig)
+        X509_EXTENSION_free(ext_qssig);
+    if (ext_qssigalg)
+        X509_EXTENSION_free(ext_qssigalg);
+
+    /* Not sure why I don't need to free qs_pub_key_ext */
+    if (qs_sigval_attr)
+        X509_ATTRIBUTE_free(qs_sigval_attr);
+    if (req_exts)
+        sk_X509_EXTENSION_pop_free(req_exts, X509_EXTENSION_free);
+
+    /* I don't need to free (qs_sigalg_attr becuase it is still referenced by
+     * the req.
+     */
+    if (passargin && passin)
+        OPENSSL_free(passin);
+    if (passargin_qs && passin_qs)
+        OPENSSL_free(passin_qs);
+
+    release_engine(e);
+    OBJ_cleanup();
+    apps_shutdown();
+    OPENSSL_EXIT(ret);
+}
diff --git a/apps/QSExtend/x509QSVerify.c b/apps/QSExtend/x509QSVerify.c
new file mode 100644
index 0000000..e457a4e
--- /dev/null
+++ b/apps/QSExtend/x509QSVerify.c
@@ -0,0 +1,617 @@
+/** @file openssl_x509QSVerify.c Verification of the QS multiple public key algorithm certificates.
+ *
+ * Isara Corporation Quantum Safe EST Proprietary Software License
+ * Statement
+ *
+ * LICENSE AGREEMENT: The Product(s) that reference this license include
+ * embedded proprietary software and software “plug-ins” in source code or
+ * object code or both (the “Software”) and accompanying materials (the
+ * “Documentation”) that are subject to the license terms and restrictions
+ * described below (the “License"). If you do not agree to the License
+ * terms, do not use the Product, notify Isara Corporation (“Isara”) by
+ * electronic mail at sales@isara.com and erase any copies of the Product
+ * in your possession. If you are entering into this License on behalf of
+ * a company or other legal entity, you represent that you have the right
+ * to bind that entity to all terms, and “you” refers both to you
+ * personally and such entity.
+ *
+ * USE AND DISTRIBUTION: You may use the Software only in the form and in
+ * the Product(s) delivered to you for the purposes of integration,
+ * development and testing with your own products and/or as part of a
+ * monitoring and/or control group beta test with third parties that agree
+ * in writing to be bound by the terms of this License.
+ *
+ * ADDITIONAL RESTRICTIONS: You shall not use, modify, reproduce, reverse
+ * engineer, disassemble, decompile or otherwise attempt to derive source
+ * code from the Software (except to the extent that such limitations may
+ * not be prohibited by law), sublicense, or distribute the Software or
+ * Documentation other than as permitted by this License. You shall not
+ * remove any proprietary notices, labels or marks on the Product(s) “ZIP
+ * file”, Software or Documentation. No license is granted to use or
+ * reproduce any Isara trademarks.
+ *
+ * OWNERSHIP AND NOTICE: Except for the limited rights granted above,
+ * Isara and its suppliers retain all right, title and interest in and to
+ * the Software and Documentation, including copyrights, patents, trade
+ * secrets and other proprietary rights. Certain components of the
+ * Software that are subject to open source and third party licenses, the
+ * terms and conditions of which can found at https://github.com/cisco and
+ * select the applicable hash-sigs or libest license filed on the Github
+ * repository. If you require additional guidance, notify sales@isara.com
+ * for assistance. As a condition of the License, you agree to comply with
+ * all of the foregoing open source and third party license terms. Unless
+ * required by applicable law, such components are provided on an ‘AS IS’
+ * BASIS, WITHOUT EXPRESS OR IMPLIED WARRANTIES OR CONDITIONS OF ANY KIND.
+ *
+ * WARRANTY DISCLAIMER: THE SOFTWARE AND DOCUMENTATION ARE PROVIDED TO YOU
+ * "AS IS", AND YOU ASSUME THE ENTIRE RISK OF THEIR USE. ISARA AND ITS
+ * SUPPLIERS MAKES NO WARRANTIES OR CONDITIONS, EXPRESS, IMPLIED,
+ * STATUTORY OR IN ANY COMMUNICATION WITH YOU, AND ISARA CORPORATION
+ * EXPRESSLY DISCLAIMS ANY IMPLIED WARRANTIES OF MERCHANTABILITY, FITNESS
+ * FOR A PARTICULAR PURPOSE OR NONINFRINGEMENT WITH RESPECT TO THE
+ * SOFTWARE (INCLUDING ANY MODIFICATIONS MADE THERETO BY ANY PERSON
+ * WHETHER OR NOT AN EMPLOYEE OR CONTRACTOR OF ISARA) OR DOCUMENTATION
+ * PROVIDED TO YOU. ISARA EMPLOYEES AND OTHER PERSONNEL ARE NOT AUTHORIZED
+ * TO MAKE ANY WARRANTY THAT IS INCONSISTENT WITH THIS DISCLAIMER.
+ *
+ * LIMITATION OF LIABILITY: IN NO EVENT WILL ISARA OR ITS SUPPLIERS AND
+ * SUPPLIERS BE LIABLE FOR LOSS OF DATA, LOST PROFITS, COST OF COVER, OR
+ * OTHER SPECIAL, INCIDENTAL, PUNITIVE, CONSEQUENTIAL, OR INDIRECT DAMAGES
+ * ARISING FROM USE OF THE SOFTWARE OR DOCUMENTATION, HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, AND REGARDLESS OF WHETHER ISARA OR ITS
+ * SUPPLIERS HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  ISARA
+ * AND ITS SUPPLIERS BEAR NO LIABILITY FOR ANY PROGRAMS OR DATA STORED IN
+ * OR USED WITH THIS PRODUCT, INCLUDING THE COST OF RECOVERING SUCH
+ * PROGRAMS OR DATA.
+ *
+ * Copyright (c) 2017 ISARA Corporation. All Rights Reserved. This file
+ * contains Proprietary information of Isara Corporation. Unauthorized
+ * copying or use of this file via any medium is strictly prohibited.
+ * Written by Anthony Hu, anthony.hu@isara.com; Daniel Van Geest,
+ * daniel.vangeest@isara.com, December, 2017.
+ */
+
+/* Modified.  Was genpkey.c.
+ */
+
+/* Written by Dr Stephen N Henson (steve@openssl.org) for the OpenSSL project
+ * 2006
+ */
+/* ====================================================================
+ * Copyright (c) 2006 The OpenSSL Project.  All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * 3. All advertising materials mentioning features or use of this
+ *    software must display the following acknowledgment:
+ *    "This product includes software developed by the OpenSSL Project
+ *    for use in the OpenSSL Toolkit. (http://www.OpenSSL.org/)"
+ *
+ * 4. The names "OpenSSL Toolkit" and "OpenSSL Project" must not be used to
+ *    endorse or promote products derived from this software without
+ *    prior written permission. For written permission, please contact
+ *    licensing@OpenSSL.org.
+ *
+ * 5. Products derived from this software may not be called "OpenSSL"
+ *    nor may "OpenSSL" appear in their names without prior written
+ *    permission of the OpenSSL Project.
+ *
+ * 6. Redistributions of any form whatsoever must retain the following
+ *    acknowledgment:
+ *    "This product includes software developed by the OpenSSL Project
+ *    for use in the OpenSSL Toolkit (http://www.OpenSSL.org/)"
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE OpenSSL PROJECT ``AS IS'' AND ANY
+ * EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE OpenSSL PROJECT OR
+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
+ * OF THE POSSIBILITY OF SUCH DAMAGE.
+ * ====================================================================
+ *
+ * This product includes cryptographic software written by Eric Young
+ * (eay@cryptsoft.com).  This product includes software written by Tim
+ * Hudson (tjh@cryptsoft.com).
+ *
+ */
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+
+#include "../apps/apps.h"
+#include <openssl/pem.h>
+#include <openssl/err.h>
+#include <openssl/evp.h>
+#include <openssl/engine.h>
+#include <openssl/x509.h>
+#include <openssl/x509v3.h>
+#include <openssl/asn1.h>
+
+static int x509qsverify_load_certs(BIO *err, BIO *bio,
+                      const char *pass, ENGINE *e,
+                      STACK_OF(X509) **pcerts)
+{
+    int i;
+    STACK_OF(X509_INFO) *xis = NULL;
+    X509_INFO *xi;
+    int rv = 0;
+
+    xis = PEM_X509_INFO_read_bio(bio, NULL, NULL, NULL);
+
+    if (pcerts) {
+        *pcerts = sk_X509_new_null();
+        if (!*pcerts)
+            goto end;
+    }
+
+    for (i = 0; i < sk_X509_INFO_num(xis); i++) {
+        xi = sk_X509_INFO_value(xis, i);
+        if (xi->x509 && pcerts) {
+            if (!sk_X509_push(*pcerts, xi->x509))
+                goto end;
+            xi->x509 = NULL;
+        }
+    }
+
+    if (pcerts && sk_X509_num(*pcerts) > 0)
+        rv = 1;
+
+ end:
+
+    if (xis)
+        sk_X509_INFO_pop_free(xis, X509_INFO_free);
+
+    if (rv == 0) {
+        if (pcerts) {
+            sk_X509_pop_free(*pcerts, X509_free);
+            *pcerts = NULL;
+        }
+        BIO_printf(err, "unable to load certificates.\n");
+        ERR_print_errors(err);
+    }
+    return rv;
+}
+
+#define X509_NAME_LINE_LENGTH 128
+
+/* on WIN16 you need to add `_far _loadds` */
+static int cb(int ok, X509_STORE_CTX *ctx) {
+    X509 *current_cert = X509_STORE_CTX_get_current_cert(ctx);
+    int cert_error = X509_STORE_CTX_get_error(ctx);
+    int cert_depth = X509_STORE_CTX_get_error_depth(ctx);
+    STACK_OF(X509) *chain = X509_STORE_CTX_get1_chain(ctx);
+    ASN1_BIT_STRING *new_sig = NULL;
+    X509 * alt_free_cert = NULL;
+    X509 *issuer = NULL;
+
+    int qs_pub_key_ind = -1;
+    X509_EXTENSION *qs_pub_key_ext = NULL;
+
+    int qs_sigalg_ind = -1;
+    X509_ALGOR *qssigalg = NULL;
+    X509_EXTENSION *qs_sigalg_ext = NULL;
+
+    int alg_nid = -1;
+    int qs_sigval_ind = -1;
+    X509_EXTENSION *qs_sigval_ext = NULL;
+    X509_EXTENSION *new_qs_sigval_ext = NULL;
+
+    X509_PUBKEY *x509_pub_qs = NULL;
+    SUBJECT_ALT_PUBLIC_KEY_INFO *sapki = NULL;
+    ASN1_BIT_STRING *qssig = NULL;
+    EVP_PKEY * qs_pub_key = NULL;
+    X509_ALGOR *algo_holder = NULL;
+
+    char cert_name[X509_NAME_LINE_LENGTH];
+
+    if (!ok) {
+        if (current_cert) {
+            X509_NAME_print_ex_fp(stderr,
+                                  X509_get_subject_name(current_cert),
+                                  0, XN_FLAG_ONELINE);
+            fprintf(stderr, "\n");
+        }
+        printf("%serror %d at %d depth lookup:%s\n",
+               X509_STORE_CTX_get0_parent_ctx(ctx) ? "[CRL path]" : "",
+               cert_error,
+               X509_STORE_CTX_get_error_depth(ctx),
+               X509_verify_cert_error_string(cert_error));
+        switch (cert_error) {
+        case X509_V_ERR_NO_EXPLICIT_POLICY:
+        case X509_V_ERR_CERT_HAS_EXPIRED:
+
+            /*
+             * since we are just checking the certificates, it is ok if they
+             * are self signed. But we should still warn the user.
+             */
+
+        case X509_V_ERR_DEPTH_ZERO_SELF_SIGNED_CERT:
+            /* Continue after extension errors too */
+        case X509_V_ERR_INVALID_CA:
+        case X509_V_ERR_INVALID_NON_CA:
+        case X509_V_ERR_PATH_LENGTH_EXCEEDED:
+        case X509_V_ERR_INVALID_PURPOSE:
+        case X509_V_ERR_CRL_HAS_EXPIRED:
+        case X509_V_ERR_CRL_NOT_YET_VALID:
+        case X509_V_ERR_UNHANDLED_CRITICAL_EXTENSION:
+            ok = 1;
+
+        }
+    }
+
+    if (chain == NULL) {
+        fprintf(stderr, "Error getting a certificate chain to verify.\n");
+        goto end;
+    }
+
+    if (current_cert == NULL) {
+        fprintf(stderr, "Error getting a certificate to verify.\n");
+        goto end;
+    }
+
+    if (sk_X509_num(chain) - 1 == cert_depth) {
+        /* This is a root cert.  If it is self signed then there is no point
+         * in verifying it. If is is NOT self signed then we don't have the
+         * signer cert so we cannot verify it.
+         */
+        goto end;
+    }
+
+    /* This is where the QS verification actually is done. */
+    ok = 0;
+
+    /* Grab the next cert in the stack. That should be the issuer. OpenSSL
+     * should have checked that for us so we don't bother with any checks.
+     * We simply get the QS public key out of the extensions and convert
+     * it to a pkey.
+     */
+    issuer = sk_X509_value(chain, cert_depth + 1);
+    if (issuer == NULL) {
+        fprintf(stderr, "Error finding the issuer certificate.\n");
+        goto end;
+    }
+
+    /* Find the issuer's ALT public key extension. */
+    qs_pub_key_ind = X509_get_ext_by_NID(issuer, NID_subj_alt_pub_key, -1);
+    if (qs_pub_key_ind < 0) {
+        fprintf(stderr, "Error finding the issuer's ALT pulbic key extension.\n");
+        goto end;
+    }
+
+    /* Get the issuer's ALT public key extension. */
+    qs_pub_key_ext = X509_get_ext(issuer, qs_pub_key_ind);
+    if (qs_pub_key_ext == NULL) {
+        fprintf(stderr, "Error getting the issuer's ALT public key extension.\n");
+        goto end;
+    }
+
+    /* ASN.1 parse the ALT public key extension. */
+    sapki = X509V3_EXT_d2i(qs_pub_key_ext);
+    if (sapki == NULL) {
+        fprintf(stderr, "Error converting the issuer's ALT public key extension into ASN.1.\n");
+        goto end;
+    }
+
+    /* Convert the x509 formatted public key into a pkey */
+    x509_pub_qs = X509_PUBKEY_new();
+    if (x509_pub_qs == NULL) {
+        fprintf(stderr, "Memory allocation error.\n");
+        goto end;
+    }
+    X509_ALGOR_free(x509_pub_qs->algor);
+    ASN1_BIT_STRING_free(x509_pub_qs->public_key);
+
+    x509_pub_qs->algor = sapki->algor;
+    x509_pub_qs->public_key = sapki->public_key;
+    x509_pub_qs->pkey = NULL;
+
+    qs_pub_key = X509_PUBKEY_get(x509_pub_qs);
+
+    x509_pub_qs->algor = NULL;
+    x509_pub_qs->public_key = NULL;
+    X509_PUBKEY_free(x509_pub_qs);
+    x509_pub_qs = NULL;
+
+    if (qs_pub_key == NULL) {
+        fprintf(stderr, "Error converting ALT public key into a PKEY.\n");
+        goto end;
+    }
+
+    /* Find the ALT signature algorithm extension and convert it into data. */
+    qs_sigalg_ind = X509_get_ext_by_NID(current_cert, NID_alt_sigalg, -1);
+    if (qs_sigalg_ind < 0) {
+        fprintf(stderr, "Error finding the certificate's ALT signature algorithm extension.\n");
+        goto end;
+    }
+
+    qs_sigalg_ext = X509_get_ext(current_cert, qs_sigalg_ind);
+    if (qs_sigalg_ext == NULL) {
+        fprintf(stderr, "Error getting the certificate's ALT signature algorithm extension.\n");
+        goto end;
+    }
+
+    qssigalg = X509V3_EXT_d2i(qs_sigalg_ext);
+    if (qssigalg == NULL) {
+        fprintf(stderr, "Error converting the issuer's ALT signature algorithm extension into ASN.1.\n");
+        goto end;
+    }
+
+    /* Find the ALT signature extension and convert it into data. */
+    qs_sigval_ind = X509_get_ext_by_NID(current_cert, NID_alt_sigval, -1);
+    if (qs_sigval_ind < 0) {
+        fprintf(stderr, "Error finding the certificate's ALT signature extension.\n");
+        goto end;
+    }
+
+    qs_sigval_ext = X509_get_ext(current_cert, qs_sigval_ind);
+    if (qs_sigval_ext == NULL) {
+        fprintf(stderr, "Error getting the certificate's ALT signature extension.\n");
+        goto end;
+    }
+
+    qssig = X509V3_EXT_d2i(qs_sigval_ext);
+    if (qssig == NULL) {
+        fprintf(stderr, "Error converting the issuer's ALT signature extension into ASN.1.\n");
+        goto end;
+    }
+
+    /* Ensure that the signature algorithm specified in the signature extension
+     * and the alogrithm of the issuer's public key matches. We can't use
+     * X509_ALGOR_cmp() because the OIDs don't match. The signature one includes
+     * information about the digest. We don't worry about digest and parameter
+     * mismatch as the actual verification will catch that.
+     */
+    if (OBJ_find_sigid_algs(OBJ_obj2nid(qssigalg->algorithm), NULL, &alg_nid) == 0) {
+        fprintf(stderr, "Couldn't get the algorithm ID from the ALT signature.\n");
+        goto end;
+    }
+
+    if (alg_nid != OBJ_obj2nid(sapki->algor->algorithm)) {
+        fprintf(stderr, "Issuer public key algorithm does not match signature algorithm\n");
+        goto end;
+    }
+
+    new_sig = M_ASN1_BIT_STRING_dup(qssig);
+    if (new_sig == NULL) {
+        fprintf(stderr, "Error duplicating the ALT signature.\n");
+        goto end;
+    }
+
+    /* Now duplicate the current certificate, remove the ALT signature extension
+     * and verify against that. We hid the classical algorithm during the signing
+     * process so we also have to do it again to verify against the same thing.
+     */
+    alt_free_cert = X509_dup(current_cert);
+    if (alt_free_cert == NULL) {
+        fprintf(stderr, "Error duplicating the certificate.\n");
+        goto end;
+    }
+
+    qs_sigval_ind = X509_get_ext_by_NID(alt_free_cert, NID_alt_sigval, -1);
+    if (qs_sigval_ind < 0) {
+        fprintf(stderr, "Error getting the ALT signature extension.\n");
+        goto end;
+    }
+
+    new_qs_sigval_ext = X509_get_ext(alt_free_cert, qs_sigval_ind);
+    if (new_qs_sigval_ext == NULL) {
+        fprintf(stderr, "Error getting duplicate ALT signature extension to deallocate it.\n");
+        goto end;
+    }
+
+    if (X509_delete_ext(alt_free_cert, qs_sigval_ind) == NULL) {
+        fprintf(stderr, "Error removing the ALT signature extension.\n");
+        goto end;
+    }
+
+    algo_holder = alt_free_cert->cert_info->signature;
+    alt_free_cert->cert_info->signature = NULL;
+
+    /* Encoded data is being cached.  See https://www.openssl.org/docs/man1.1.0/crypto/X509_sign.html.
+     * Setting this flag ensures the cache is ignored.
+     */
+    alt_free_cert->cert_info->enc.modified = 1;
+
+    if (ASN1_item_verify(ASN1_ITEM_rptr(X509_CINF), qssigalg,
+                         new_sig, alt_free_cert->cert_info, qs_pub_key) <= 0) {
+        printf("QS verification FAILED!\n");
+        goto end;
+    }
+
+    ok = 1;
+
+end:
+    printf ("%d : %s : %s\n", cert_depth, ok == 1 ? "ok" : "not ok", X509_NAME_oneline(X509_get_subject_name(current_cert), cert_name, X509_NAME_LINE_LENGTH));
+
+    if (chain)
+        sk_X509_pop_free(chain, X509_free);
+    if (sapki)
+        SUBJECT_ALT_PUBLIC_KEY_INFO_free(sapki);
+    if (qssig)
+        ASN1_BIT_STRING_free(qssig);
+    if (alt_free_cert)
+        X509_free(alt_free_cert);
+    if (qs_pub_key)
+        EVP_PKEY_free(qs_pub_key);
+    if (new_sig)
+        ASN1_BIT_STRING_free(new_sig);
+    if (qssigalg)
+        X509_ALGOR_free(qssigalg);
+    if (new_qs_sigval_ext)
+        X509_EXTENSION_free(new_qs_sigval_ext);
+    if (algo_holder)
+        X509_ALGOR_free(algo_holder);
+
+    return ok;
+}
+
+#undef PROG
+#define PROG    x509QSVerify_main
+
+int MAIN(int, char **);
+
+int MAIN(int argc, char **argv)
+{
+    char **args;
+    int badarg = 0;
+    int ret = 1;
+    int err_code = 0;
+
+    ENGINE *e = NULL;
+    BIO *bio_cert = NULL;
+    BIO *bio_trusted = NULL;
+    BIO *bio_untrusted = NULL;
+
+    X509 *cert = NULL;
+    STACK_OF(X509) *trusted = NULL;
+    STACK_OF(X509) *untrusted = NULL;
+
+    X509_STORE *cert_store = NULL;
+    X509_STORE_CTX *cert_store_ctx = NULL;
+
+    bio_err = BIO_new_fp(stderr, BIO_NOCLOSE);
+
+    CRYPTO_malloc_debug_init();
+    CRYPTO_set_mem_debug_options(V_CRYPTO_MDEBUG_ALL);
+    CRYPTO_mem_ctrl(CRYPTO_MEM_CHECK_ON);
+
+    ERR_load_crypto_strings();
+    ENGINE_load_dynamic();
+
+    args = argv + 1;
+    while (!badarg && *args && *args[0] == '-') {
+        if (strcmp(*args, "-engine") == 0) {
+            if (!args[1])
+                goto bad;
+            e = setup_engine(bio_err, *(++args), 0);
+            if (e == NULL)
+                goto end;
+        } else if (strcmp(*args, "-root") == 0) {
+            if (!args[1])
+                goto bad;
+            bio_trusted = BIO_new_file(*(++args), "rb");
+        } else if (strcmp(*args, "-untrusted") == 0) {
+            if (!args[1])
+                goto bad;
+            bio_untrusted = BIO_new_file(*(++args), "rb");
+        } else if (strcmp(*args, "-cert") == 0) {
+            if (!args[1])
+                goto bad;
+            bio_cert = BIO_new_file(*(++args), "rb");
+        } else {
+            badarg = 1;
+        }
+        args++;
+    }
+
+    if (bio_trusted == NULL)
+        badarg = 1;
+
+    if (bio_cert == NULL)
+        badarg = 1;
+
+    if (badarg) {
+bad:
+        BIO_printf(bio_err, "Usage: openssl x509QSVerify [options]\n");
+        BIO_printf(bio_err, "where options may be\n");
+        BIO_printf(bio_err,
+                   "-engine e          Use Engine library <e>\n");
+        BIO_printf(bio_err,
+                   "-root file         The self signed X509 root certificates concatenated into a single file.\n");
+        BIO_printf(bio_err,
+                   "-untrusted file    All the untrusted certificates concatenated into a single file.\n");
+        BIO_printf(bio_err,
+                   "-cert file         The certificate to be verified.\n");
+        goto end;
+    }
+
+    cert_store = X509_STORE_new();
+    if (cert_store == NULL) {
+        goto end;
+    }
+
+    X509_STORE_set_verify_cb(cert_store, cb);
+
+    if (x509qsverify_load_certs(bio_err, bio_trusted, NULL, NULL, &trusted) == 0) {
+        BIO_printf(bio_err, "Error loading trusted certs.\n");
+        goto end;
+    }
+
+    if (bio_untrusted != NULL) {
+        if (x509qsverify_load_certs(bio_err, bio_untrusted, NULL, NULL, &untrusted) == 0) {
+            BIO_printf(bio_err, "Error loading untrusted certs.\n");
+            goto end;
+        }
+    }
+
+    cert = PEM_read_bio_X509(bio_cert, NULL, NULL, NULL);
+    if (cert == NULL) {
+        BIO_printf(bio_err, "Error loading cert to be verified.\n");
+        goto end;
+    }
+
+    cert_store_ctx = X509_STORE_CTX_new();
+    if (cert_store_ctx == NULL) {
+        ERR_print_errors(bio_err);
+        goto end;
+    }
+
+    X509_STORE_set_flags(cert_store, 0);
+
+    if (X509_STORE_CTX_init(cert_store_ctx, cert_store, cert, untrusted) == 0) {
+        ERR_print_errors(bio_err);
+        goto end;
+    }
+    X509_STORE_CTX_trusted_stack(cert_store_ctx, trusted);
+
+    if((X509_verify_cert(cert_store_ctx) == 1) && ((err_code = X509_STORE_CTX_get_error(cert_store_ctx)) == X509_V_OK)) {
+        ret = 0;
+    } else {
+        BIO_printf(bio_err, "Certificate chain verification failed with error code %d.\n", err_code);
+    }
+
+ end:
+    if (ret == 0)
+        BIO_printf(bio_err, "Success!!\n");
+    else
+        ERR_print_errors(bio_err);
+
+    if (bio_cert)
+        BIO_free_all(bio_cert);
+    if (bio_trusted)
+        BIO_free_all(bio_trusted);
+    if (bio_untrusted)
+        BIO_free_all(bio_untrusted);
+    if (cert)
+        X509_free(cert);
+    if (trusted)
+        sk_X509_pop_free(trusted, X509_free);
+    if (untrusted)
+        sk_X509_pop_free(untrusted, X509_free);
+    if (cert_store)
+        X509_STORE_free(cert_store);
+    if (cert_store_ctx) {
+        X509_STORE_CTX_cleanup(cert_store_ctx);
+        X509_STORE_CTX_free(cert_store_ctx);
+    }
+    release_engine(e);
+    OBJ_cleanup();
+    apps_shutdown();
+    OPENSSL_EXIT(ret);
+}
diff --git a/apps/progs.h b/apps/progs.h
index d5c0039..3abbc96 100644
--- a/apps/progs.h
+++ b/apps/progs.h
@@ -47,6 +47,10 @@ extern int ocsp_main(int argc, char *argv[]);
 extern int prime_main(int argc, char *argv[]);
 extern int ts_main(int argc, char *argv[]);
 extern int srp_main(int argc, char *argv[]);
+extern int reqQSExtend_main(int argc, char *argv[]);
+extern int x509QSExtend_main(int argc, char *argv[]);
+extern int x509QSDirectExtend_main(int argc, char *argv[]);
+extern int x509QSVerify_main(int argc, char *argv[]);
 
 #define FUNC_TYPE_GENERAL       1
 #define FUNC_TYPE_MD            2
@@ -151,6 +155,10 @@ FUNCTION functions[] = {
 #ifndef OPENSSL_NO_SRP
     {FUNC_TYPE_GENERAL, "srp", srp_main},
 #endif
+    {FUNC_TYPE_GENERAL, "reqQSExtend", reqQSExtend_main},
+    {FUNC_TYPE_GENERAL, "x509QSExtend", x509QSExtend_main},
+    {FUNC_TYPE_GENERAL, "x509QSDirectExtend", x509QSDirectExtend_main},
+    {FUNC_TYPE_GENERAL, "x509QSVerify", x509QSVerify_main},
 #ifndef OPENSSL_NO_MD2
     {FUNC_TYPE_MD, "md2", dgst_main},
 #endif
diff --git a/apps/s_apps.h b/apps/s_apps.h
index 5ba1e1d..6ba2412 100644
--- a/apps/s_apps.h
+++ b/apps/s_apps.h
@@ -160,7 +160,7 @@ int MS_CALLBACK verify_callback(int ok, X509_STORE_CTX *ctx);
 #endif
 #ifdef HEADER_SSL_H
 int set_cert_stuff(SSL_CTX *ctx, char *cert_file, char *key_file);
-int set_cert_key_stuff(SSL_CTX *ctx, X509 *cert, EVP_PKEY *key,
+int set_cert_key_stuff(SSL_CTX *ctx, X509 *cert, EVP_PKEY *key, EVP_PKEY *qs_key,
                        STACK_OF(X509) *chain, int build_chain);
 int ssl_print_sigalgs(BIO *out, SSL *s);
 int ssl_print_point_formats(BIO *out, SSL *s);
diff --git a/apps/s_cb.c b/apps/s_cb.c
index f8051bf..accf0ae 100644
--- a/apps/s_cb.c
+++ b/apps/s_cb.c
@@ -251,7 +251,7 @@ int set_cert_stuff(SSL_CTX *ctx, char *cert_file, char *key_file)
     return (1);
 }
 
-int set_cert_key_stuff(SSL_CTX *ctx, X509 *cert, EVP_PKEY *key,
+int set_cert_key_stuff(SSL_CTX *ctx, X509 *cert, EVP_PKEY *key, EVP_PKEY *qs_key,
                        STACK_OF(X509) *chain, int build_chain)
 {
     int chflags = chain ? SSL_BUILD_CHAIN_FLAG_CHECK : 0;
@@ -278,6 +278,14 @@ int set_cert_key_stuff(SSL_CTX *ctx, X509 *cert, EVP_PKEY *key,
         return 0;
     }
 
+    if (qs_key != NULL) {
+        if (SSL_CTX_use_ALTPrivateKey(ctx, qs_key) <= 0) {
+            BIO_printf(bio_err, "error setting ALT private key\n");
+            ERR_print_errors(bio_err);
+            return 0;
+        }
+    }
+
     if (chain && !SSL_CTX_set1_chain(ctx, chain)) {
         BIO_printf(bio_err, "error setting certificate chain\n");
         ERR_print_errors(bio_err);
diff --git a/apps/s_client.c b/apps/s_client.c
index 4408529..7517b85 100644
--- a/apps/s_client.c
+++ b/apps/s_client.c
@@ -671,11 +671,11 @@ int MAIN(int argc, char **argv)
     short port = PORT;
     int full_log = 1;
     char *host = SSL_HOST_NAME;
-    char *cert_file = NULL, *key_file = NULL, *chain_file = NULL;
+    char *cert_file = NULL, *key_file = NULL, *chain_file = NULL, *qs_key_file = NULL;
     int cert_format = FORMAT_PEM, key_format = FORMAT_PEM;
     char *passarg = NULL, *pass = NULL;
     X509 *cert = NULL;
-    EVP_PKEY *key = NULL;
+    EVP_PKEY *key = NULL, *qs_key = NULL;
     STACK_OF(X509) *chain = NULL;
     char *CApath = NULL, *CAfile = NULL;
     char *chCApath = NULL, *chCAfile = NULL;
@@ -1004,6 +1004,10 @@ int MAIN(int argc, char **argv)
             if (--argc < 1)
                 goto bad;
             key_file = *(++argv);
+        } else if (strcmp(*argv, "-qs_key") == 0) {
+            if (--argc < 1)
+                goto bad;
+            qs_key_file = *(++argv);
         } else if (strcmp(*argv, "-reconnect") == 0) {
             reconnect = 5;
         } else if (strcmp(*argv, "-CApath") == 0) {
@@ -1222,6 +1226,21 @@ int MAIN(int argc, char **argv)
         }
     }
 
+    if (qs_key_file != NULL) {
+        qs_key = load_key(bio_err, qs_key_file, key_format, 0, pass, e,
+                                 "client certificate qs private key file");
+        if (!qs_key) {
+            ERR_print_errors(bio_err);
+            goto end;
+        }
+        if (qs_key->type == EVP_PKEY_HSS) {
+            if (!set_hss_pkey_filename(qs_key, qs_key_file)) {
+                ERR_print_errors(bio_err);
+                goto end;
+            }
+        }
+    }
+
     if (cert_file) {
         cert = load_cert(bio_err, cert_file, cert_format,
                          NULL, e, "client certificate file");
@@ -1381,7 +1400,7 @@ int MAIN(int argc, char **argv)
     }
 
     ssl_ctx_add_crls(ctx, crls, crl_download);
-    if (!set_cert_key_stuff(ctx, cert, key, chain, build_chain))
+    if (!set_cert_key_stuff(ctx, cert, key, qs_key, chain, build_chain))
         goto end;
 
 #ifndef OPENSSL_NO_TLSEXT
@@ -2102,6 +2121,8 @@ int MAIN(int argc, char **argv)
         sk_X509_CRL_pop_free(crls, X509_CRL_free);
     if (key)
         EVP_PKEY_free(key);
+    if (qs_key)
+        EVP_PKEY_free(qs_key);
     if (chain)
         sk_X509_pop_free(chain, X509_free);
     if (pass)
@@ -2253,6 +2274,12 @@ static void print_stuff(BIO *bio, SSL *s, int full)
         BIO_printf(bio, "Server public key is %d bit\n",
                    EVP_PKEY_bits(pktmp));
         EVP_PKEY_free(pktmp);
+        pktmp = SSL_get_alt_pubkey(peer);
+        if (pktmp != NULL) {
+          BIO_printf(bio, "Server alternative public key is %d bit\n",
+                     EVP_PKEY_bits(pktmp));
+          EVP_PKEY_free(pktmp);
+        }
     }
     BIO_printf(bio, "Secure Renegotiation IS%s supported\n",
                SSL_get_secure_renegotiation_support(s) ? "" : " NOT");
diff --git a/apps/s_server.c b/apps/s_server.c
index 704d349..b95973b 100644
--- a/apps/s_server.c
+++ b/apps/s_server.c
@@ -294,7 +294,7 @@ extern int verify_depth, verify_return_error, verify_quiet;
 static int s_server_verify = SSL_VERIFY_NONE;
 static int s_server_session_id_context = 1; /* anything will do */
 static const char *s_cert_file = TEST_CERT, *s_key_file =
-    NULL, *s_chain_file = NULL;
+    NULL, *s_chain_file = NULL, *s_qs_key_file = NULL;
 #ifndef OPENSSL_NO_TLSEXT
 static const char *s_cert_file2 = TEST_CERT2, *s_key_file2 = NULL;
 #endif
@@ -1103,7 +1103,7 @@ int MAIN(int argc, char *argv[])
     int s_dcert_format = FORMAT_PEM, s_dkey_format = FORMAT_PEM;
     X509 *s_cert = NULL, *s_dcert = NULL;
     STACK_OF(X509) *s_chain = NULL, *s_dchain = NULL;
-    EVP_PKEY *s_key = NULL, *s_dkey = NULL;
+    EVP_PKEY *s_key = NULL, *s_dkey = NULL, *s_qs_key = NULL;
     int no_cache = 0, ext_cache = 0;
     int rev = 0, naccept = -1;
 #ifndef OPENSSL_NO_TLSEXT
@@ -1227,6 +1227,10 @@ int MAIN(int argc, char *argv[])
             if (--argc < 1)
                 goto bad;
             s_key_file = *(++argv);
+        } else if (strcmp(*argv, "-qs_key") == 0) {
+            if (--argc < 1)
+                goto bad;
+            s_qs_key_file = *(++argv);
         } else if (strcmp(*argv, "-keyform") == 0) {
             if (--argc < 1)
                 goto bad;
@@ -1630,6 +1634,21 @@ int MAIN(int argc, char *argv[])
             }
         }
 
+        if (s_qs_key_file != NULL) {
+            s_qs_key = load_key(bio_err, s_qs_key_file, s_key_format, 0, pass, e,
+                                     "server certificate qs private key file");
+            if (!s_qs_key) {
+                ERR_print_errors(bio_err);
+                goto end;
+            }
+            if (s_qs_key->type == EVP_PKEY_HSS) {
+                if (!set_hss_pkey_filename(s_qs_key, s_qs_key_file)) {
+                    ERR_print_errors(bio_err);
+                    goto end;
+                }
+            }
+        }
+
         s_cert = load_cert(bio_err, s_cert_file, s_cert_format,
                            NULL, e, "server certificate file");
 
@@ -1754,6 +1773,7 @@ int MAIN(int argc, char *argv[])
     {
         s_cert_file = NULL;
         s_key_file = NULL;
+        s_qs_key_file = NULL;
         s_dcert_file = NULL;
         s_dkey_file = NULL;
 #ifndef OPENSSL_NO_TLSEXT
@@ -1939,7 +1959,7 @@ int MAIN(int argc, char *argv[])
     }
 #endif
 
-    if (!set_cert_key_stuff(ctx, s_cert, s_key, s_chain, build_chain))
+    if (!set_cert_key_stuff(ctx, s_cert, s_key, s_qs_key, s_chain, build_chain))
         goto end;
 #ifndef OPENSSL_NO_TLSEXT
     if (s_serverinfo_file != NULL
@@ -1949,11 +1969,11 @@ int MAIN(int argc, char *argv[])
     }
 #endif
 #ifndef OPENSSL_NO_TLSEXT
-    if (ctx2 && !set_cert_key_stuff(ctx2, s_cert2, s_key2, NULL, build_chain))
+    if (ctx2 && !set_cert_key_stuff(ctx2, s_cert2, s_key2, NULL, NULL, build_chain))
         goto end;
 #endif
     if (s_dcert != NULL) {
-        if (!set_cert_key_stuff(ctx, s_dcert, s_dkey, s_dchain, build_chain))
+        if (!set_cert_key_stuff(ctx, s_dcert, s_dkey, NULL, s_dchain, build_chain))
             goto end;
     }
 #ifndef OPENSSL_NO_RSA
@@ -2085,6 +2105,8 @@ int MAIN(int argc, char *argv[])
         X509_free(s_dcert);
     if (s_key)
         EVP_PKEY_free(s_key);
+    if (s_qs_key)
+        EVP_PKEY_free(s_qs_key);
     if (s_dkey)
         EVP_PKEY_free(s_dkey);
     if (s_chain)
diff --git a/crypto/objects/obj_dat.h b/crypto/objects/obj_dat.h
index 7d6c8c2..d7fedb4 100644
--- a/crypto/objects/obj_dat.h
+++ b/crypto/objects/obj_dat.h
@@ -62,12 +62,12 @@
  * [including the GNU Public Licence.]
  */
 
-#define NUM_NID 967
-#define NUM_SN 960
-#define NUM_LN 960
-#define NUM_OBJ 899
+#define NUM_NID 973
+#define NUM_SN 966
+#define NUM_LN 966
+#define NUM_OBJ 905
 
-static const unsigned char lvalues[6316]={
+static const unsigned char lvalues[6364]={
 0x2A,0x86,0x48,0x86,0xF7,0x0D,               /* [  0] OBJ_rsadsi */
 0x2A,0x86,0x48,0x86,0xF7,0x0D,0x01,          /* [  6] OBJ_pkcs */
 0x2A,0x86,0x48,0x86,0xF7,0x0D,0x02,0x02,     /* [ 13] OBJ_md2 */
@@ -961,6 +961,12 @@ static const unsigned char lvalues[6316]={
 0x04,0x00,0x7F,0x00,0x0F,0x01,0x03,0x01,0x01,/* [6286] OBJ_HSS */
 0x04,0x00,0x7F,0x00,0x0F,0x01,0x03,0x01,0x01,0x00,/* [6295] OBJ_hss */
 0x04,0x00,0x7F,0x00,0x0F,0x01,0x03,0x01,0x01,0x01,/* [6305] OBJ_hss_with_SHA512 */
+0x04,0x00,0x7F,0x00,0x0F,0x02,               /* [6315] OBJ_ISARA_Extensions */
+0x04,0x00,0x7F,0x00,0x0F,0x02,0x01,          /* [6321] OBJ_ISARA_Certificate_Extensions */
+0x04,0x00,0x7F,0x00,0x0F,0x02,0x01,0x01,     /* [6328] OBJ_ISARA_X509_Certificate_Extensions */
+0x04,0x00,0x7F,0x00,0x0F,0x02,0x01,0x01,0x01,/* [6336] OBJ_subj_alt_pub_key */
+0x04,0x00,0x7F,0x00,0x0F,0x02,0x01,0x01,0x02,/* [6345] OBJ_alt_sigval */
+0x04,0x00,0x7F,0x00,0x0F,0x02,0x01,0x01,0x03,/* [6354] OBJ_alt_sigalg */
 };
 
 static const ASN1_OBJECT nid_objs[NUM_NID]={
@@ -2537,6 +2543,18 @@ static const ASN1_OBJECT nid_objs[NUM_NID]={
 	10,&(lvalues[6295]),0},
 {"hss-with-SHA512","hss-with-SHA512",NID_hss_with_SHA512,10,
 	&(lvalues[6305]),0},
+{"ISARA-Extensions","ISARA-Extensions",NID_ISARA_Extensions,6,
+	&(lvalues[6315]),0},
+{"ISARA-Certificate-Extensions","ISARA-Certificate-Extensions",
+	NID_ISARA_Certificate_Extensions,7,&(lvalues[6321]),0},
+{"ISARA-X509-Certificate-Extensions",
+	"ISARA-X509-Certificate-Extensions",
+	NID_ISARA_X509_Certificate_Extensions,8,&(lvalues[6328]),0},
+{"ALTSub","Subject-Alt-Public-Key-Info",NID_subj_alt_pub_key,9,
+	&(lvalues[6336]),0},
+{"ALTSigVal","Alt-Signature-Value",NID_alt_sigval,9,&(lvalues[6345]),0},
+{"ALTSigalg","Alt-Signature-Algorithm",NID_alt_sigalg,9,
+	&(lvalues[6354]),0},
 };
 
 static const unsigned int sn_objs[NUM_SN]={
@@ -2570,6 +2588,9 @@ static const unsigned int sn_objs[NUM_SN]={
 426,	/* "AES-256-ECB" */
 428,	/* "AES-256-OFB" */
 914,	/* "AES-256-XTS" */
+971,	/* "ALTSigVal" */
+972,	/* "ALTSigalg" */
+970,	/* "ALTSub" */
 91,	/* "BF-CBC" */
 93,	/* "BF-CFB" */
 92,	/* "BF-ECB" */
@@ -2640,6 +2661,9 @@ static const unsigned int sn_objs[NUM_SN]={
 46,	/* "IDEA-OFB" */
 960,	/* "ISARA" */
 961,	/* "ISARA-Algorithms" */
+968,	/* "ISARA-Certificate-Extensions" */
+967,	/* "ISARA-Extensions" */
+969,	/* "ISARA-X509-Certificate-Extensions" */
 963,	/* "ISARA-demos" */
 962,	/* "ISARA-misc" */
 181,	/* "ISO" */
@@ -3506,6 +3530,8 @@ static const unsigned int ln_objs[NUM_LN]={
 363,	/* "AD Time Stamping" */
 405,	/* "ANSI X9.62" */
 368,	/* "Acceptable OCSP Responses" */
+972,	/* "Alt-Signature-Algorithm" */
+971,	/* "Alt-Signature-Value" */
 910,	/* "Any Extended Key Usage" */
 664,	/* "Any language" */
 177,	/* "Authority Information Access" */
@@ -3554,6 +3580,9 @@ static const unsigned int ln_objs[NUM_LN]={
 296,	/* "IPSec User" */
 960,	/* "ISARA" */
 961,	/* "ISARA-Algorithms" */
+968,	/* "ISARA-Certificate-Extensions" */
+967,	/* "ISARA-Extensions" */
+969,	/* "ISARA-X509-Certificate-Extensions" */
 963,	/* "ISARA-demos" */
 962,	/* "ISARA-misc" */
 182,	/* "ISO Member Body" */
@@ -3617,6 +3646,7 @@ static const unsigned int ln_objs[NUM_LN]={
 394,	/* "Selected Attribute Types" */
 143,	/* "Strong Extranet ID" */
 398,	/* "Subject Information Access" */
+970,	/* "Subject-Alt-Public-Key-Info" */
 130,	/* "TLS Web Client Authentication" */
 129,	/* "TLS Web Server Authentication" */
 133,	/* "Time Stamping" */
@@ -4776,6 +4806,7 @@ static const unsigned int obj_objs[NUM_OBJ]={
 744,	/* OBJ_wap_wsg_idm_ecid_wtls11      2 23 43 1 4 11 */
 745,	/* OBJ_wap_wsg_idm_ecid_wtls12      2 23 43 1 4 12 */
 961,	/* OBJ_ISARA_Algorithms             0 4 0 127 0 15 1 */
+967,	/* OBJ_ISARA_Extensions             0 4 0 127 0 15 2 */
 804,	/* OBJ_whirlpool                    1 0 10118 3 0 55 */
 124,	/* OBJ_rle_compression              1 1 1 1 666 1 */
 773,	/* OBJ_kisa                         1 2 410 200004 */
@@ -4810,6 +4841,7 @@ static const unsigned int obj_objs[NUM_OBJ]={
 634,	/* OBJ_setAttr_TokICCsig            2 23 42 3 3 5 1 */
 635,	/* OBJ_setAttr_SecDevSig            2 23 42 3 3 5 2 */
 962,	/* OBJ_ISARA_misc                   0 4 0 127 0 15 1 3 */
+968,	/* OBJ_ISARA_Certificate_Extensions 0 4 0 127 0 15 2 1 */
 436,	/* OBJ_ucl                          0 9 2342 19200300 */
 820,	/* OBJ_id_Gost28147_89_None_KeyMeshing 1 2 643 2 2 14 0 */
 819,	/* OBJ_id_Gost28147_89_CryptoPro_KeyMeshing 1 2 643 2 2 14 1 */
@@ -4882,6 +4914,7 @@ static const unsigned int obj_objs[NUM_OBJ]={
 768,	/* OBJ_camellia_256_ofb128          0 3 4401 5 3 1 9 43 */
 759,	/* OBJ_camellia_256_cfb128          0 3 4401 5 3 1 9 44 */
 963,	/* OBJ_ISARA_demos                  0 4 0 127 0 15 1 3 1 */
+969,	/* OBJ_ISARA_X509_Certificate_Extensions 0 4 0 127 0 15 2 1 1 */
 437,	/* OBJ_pilot                        0 9 2342 19200300 100 */
 776,	/* OBJ_seed_ecb                     1 2 410 200004 1 3 */
 777,	/* OBJ_seed_cbc                     1 2 410 200004 1 4 */
@@ -5057,6 +5090,9 @@ static const unsigned int obj_objs[NUM_OBJ]={
 58,	/* OBJ_netscape_cert_extension      2 16 840 1 113730 1 */
 59,	/* OBJ_netscape_data_type           2 16 840 1 113730 2 */
 964,	/* OBJ_HSS                          0 4 0 127 0 15 1 3 1 1 */
+970,	/* OBJ_subj_alt_pub_key             0 4 0 127 0 15 2 1 1 1 */
+971,	/* OBJ_alt_sigval                   0 4 0 127 0 15 2 1 1 2 */
+972,	/* OBJ_alt_sigalg                   0 4 0 127 0 15 2 1 1 3 */
 438,	/* OBJ_pilotAttributeType           0 9 2342 19200300 100 1 */
 439,	/* OBJ_pilotAttributeSyntax         0 9 2342 19200300 100 3 */
 440,	/* OBJ_pilotObjectClass             0 9 2342 19200300 100 4 */
diff --git a/crypto/objects/obj_mac.h b/crypto/objects/obj_mac.h
index adcf932..f65c029 100644
--- a/crypto/objects/obj_mac.h
+++ b/crypto/objects/obj_mac.h
@@ -2860,6 +2860,33 @@
 #define NID_hss_with_SHA512             966
 #define OBJ_hss_with_SHA512             OBJ_HSS,1L
 
+#define SN_ISARA_Extensions             "ISARA-Extensions"
+#define NID_ISARA_Extensions            967
+#define OBJ_ISARA_Extensions            OBJ_ISARA,2L
+
+#define SN_ISARA_Certificate_Extensions         "ISARA-Certificate-Extensions"
+#define NID_ISARA_Certificate_Extensions                968
+#define OBJ_ISARA_Certificate_Extensions                OBJ_ISARA_Extensions,1L
+
+#define SN_ISARA_X509_Certificate_Extensions            "ISARA-X509-Certificate-Extensions"
+#define NID_ISARA_X509_Certificate_Extensions           969
+#define OBJ_ISARA_X509_Certificate_Extensions           OBJ_ISARA_Certificate_Extensions,1L
+
+#define SN_subj_alt_pub_key             "ALTSub"
+#define LN_subj_alt_pub_key             "Subject-Alt-Public-Key-Info"
+#define NID_subj_alt_pub_key            970
+#define OBJ_subj_alt_pub_key            OBJ_ISARA_X509_Certificate_Extensions,1L
+
+#define SN_alt_sigval           "ALTSigVal"
+#define LN_alt_sigval           "Alt-Signature-Value"
+#define NID_alt_sigval          971
+#define OBJ_alt_sigval          OBJ_ISARA_X509_Certificate_Extensions,2L
+
+#define SN_alt_sigalg           "ALTSigalg"
+#define LN_alt_sigalg           "Alt-Signature-Algorithm"
+#define NID_alt_sigalg          972
+#define OBJ_alt_sigalg          OBJ_ISARA_X509_Certificate_Extensions,3L
+
 #define SN_data         "data"
 #define NID_data                434
 #define OBJ_data                OBJ_itu_t,9L
diff --git a/crypto/objects/obj_mac.num b/crypto/objects/obj_mac.num
index 4dbeabf..9f40f21 100644
--- a/crypto/objects/obj_mac.num
+++ b/crypto/objects/obj_mac.num
@@ -964,3 +964,9 @@ ISARA_demos		963
 HSS		964
 hss		965
 hss_with_SHA512		966
+ISARA_Extensions		967
+ISARA_Certificate_Extensions		968
+ISARA_X509_Certificate_Extensions		969
+subj_alt_pub_key		970
+alt_sigval		971
+alt_sigalg		972
diff --git a/crypto/objects/objects.txt b/crypto/objects/objects.txt
index 291c812..d7bd2bf 100644
--- a/crypto/objects/objects.txt
+++ b/crypto/objects/objects.txt
@@ -948,6 +948,21 @@ HSS 0                               : key-id-hss       : Leighton-Micali Hierarc
 !Cname hss-with-SHA512
 HSS 1                               : hss-with-SHA512
 
+ISARA 2                             : ISARA-Extensions
+
+ISARA-Extensions 1                  : ISARA-Certificate-Extensions
+
+ISARA-Certificate-Extensions 1      : ISARA-X509-Certificate-Extensions
+
+!Cname subj-alt-pub-key
+ISARA-X509-Certificate-Extensions 1 : ALTSub     : Subject-Alt-Public-Key-Info
+
+!Cname alt-sigval
+ISARA-X509-Certificate-Extensions 2 : ALTSigVal  : Alt-Signature-Value
+
+!Cname alt-sigalg
+ISARA-X509-Certificate-Extensions 3 : ALTSigalg  : Alt-Signature-Algorithm
+
 # ======= ISARA Addition End =======
 
 itu-t 9			: data
diff --git a/crypto/x509/x509_vfy.h b/crypto/x509/x509_vfy.h
index 5062682..c3e5d55 100644
--- a/crypto/x509/x509_vfy.h
+++ b/crypto/x509/x509_vfy.h
@@ -444,6 +444,18 @@ void X509_STORE_CTX_set_depth(X509_STORE_CTX *ctx, int depth);
  */
 # define X509_V_FLAG_NO_ALT_CHAINS               0x100000
 
+/*
+ * This is used to verify cert chains containing Multiple Public Key Algorithm
+ * certificates.
+ *
+ * If this flag is set, verification of the cert chain is done with
+ * alternative signature (unless if a cert in the chain does not contain
+ * alternative signature, then it falls back to its stock signature for that
+ * cert). Otherwise, verification is performed with the stock signature.
+ */
+# define X509_V_FLAG_ALT_SIG                     0x8000000
+
+
 # define X509_VP_FLAG_DEFAULT                    0x1
 # define X509_VP_FLAG_OVERWRITE                  0x2
 # define X509_VP_FLAG_RESET_FLAGS                0x4
diff --git a/crypto/x509v3/Makefile b/crypto/x509v3/Makefile
index 9791b77..b61b542 100644
--- a/crypto/x509v3/Makefile
+++ b/crypto/x509v3/Makefile
@@ -22,13 +22,13 @@ v3_prn.c v3_utl.c v3err.c v3_genn.c v3_alt.c v3_skey.c v3_akey.c v3_pku.c \
 v3_int.c v3_enum.c v3_sxnet.c v3_cpols.c v3_crld.c v3_purp.c v3_info.c \
 v3_ocsp.c v3_akeya.c v3_pmaps.c v3_pcons.c v3_ncons.c v3_pcia.c v3_pci.c \
 pcy_cache.c pcy_node.c pcy_data.c pcy_map.c pcy_tree.c pcy_lib.c \
-v3_asid.c v3_addr.c v3_scts.c
+v3_asid.c v3_addr.c v3_scts.c v3_qr.c
 LIBOBJ= v3_bcons.o v3_bitst.o v3_conf.o v3_extku.o v3_ia5.o v3_lib.o \
 v3_prn.o v3_utl.o v3err.o v3_genn.o v3_alt.o v3_skey.o v3_akey.o v3_pku.o \
 v3_int.o v3_enum.o v3_sxnet.o v3_cpols.o v3_crld.o v3_purp.o v3_info.o \
 v3_ocsp.o v3_akeya.o v3_pmaps.o v3_pcons.o v3_ncons.o v3_pcia.o v3_pci.o \
 pcy_cache.o pcy_node.o pcy_data.o pcy_map.o pcy_tree.o pcy_lib.o \
-v3_asid.o v3_addr.o v3_scts.o
+v3_asid.o v3_addr.o v3_scts.o v3_qr.o
 
 SRC= $(LIBSRC)
 
@@ -535,6 +535,20 @@ v3_purp.o: ../../include/openssl/sha.h ../../include/openssl/stack.h
 v3_purp.o: ../../include/openssl/symhacks.h ../../include/openssl/x509.h
 v3_purp.o: ../../include/openssl/x509_vfy.h ../../include/openssl/x509v3.h
 v3_purp.o: ../cryptlib.h v3_purp.c
+v3_qr.o: ../../e_os.h ../../include/openssl/asn1.h
+v3_qr.o: ../../include/openssl/asn1t.h ../../include/openssl/bio.h
+v3_qr.o: ../../include/openssl/buffer.h ../../include/openssl/conf.h
+v3_qr.o: ../../include/openssl/crypto.h ../../include/openssl/e_os2.h
+v3_qr.o: ../../include/openssl/ec.h ../../include/openssl/ecdh.h
+v3_qr.o: ../../include/openssl/ecdsa.h ../../include/openssl/err.h
+v3_qr.o: ../../include/openssl/evp.h ../../include/openssl/lhash.h
+v3_qr.o: ../../include/openssl/obj_mac.h ../../include/openssl/objects.h
+v3_qr.o: ../../include/openssl/opensslconf.h ../../include/openssl/opensslv.h
+v3_qr.o: ../../include/openssl/ossl_typ.h ../../include/openssl/pkcs7.h
+v3_qr.o: ../../include/openssl/safestack.h ../../include/openssl/sha.h
+v3_qr.o: ../../include/openssl/stack.h ../../include/openssl/symhacks.h
+v3_qr.o: ../../include/openssl/x509.h ../../include/openssl/x509_vfy.h
+v3_qr.o: ../../include/openssl/x509v3.h ../cryptlib.h v3_qr.c
 v3_scts.o: ../../e_os.h ../../include/openssl/asn1.h
 v3_scts.o: ../../include/openssl/bio.h ../../include/openssl/buffer.h
 v3_scts.o: ../../include/openssl/conf.h ../../include/openssl/crypto.h
diff --git a/crypto/x509v3/ext_dat.h b/crypto/x509v3/ext_dat.h
index c3a6fce..27401fe 100644
--- a/crypto/x509v3/ext_dat.h
+++ b/crypto/x509v3/ext_dat.h
@@ -70,6 +70,7 @@ extern X509V3_EXT_METHOD v3_policy_mappings, v3_policy_constraints;
 extern X509V3_EXT_METHOD v3_name_constraints, v3_inhibit_anyp, v3_idp;
 extern X509V3_EXT_METHOD v3_addr, v3_asid;
 extern X509V3_EXT_METHOD v3_ct_scts[];
+extern X509V3_EXT_METHOD v3_alt_sigalg, v3_alt_sigval, v3_subject_alt_public_key_info;
 
 /*
  * This table will be searched using OBJ_bsearch so it *must* kept in order
@@ -129,6 +130,9 @@ static const X509V3_EXT_METHOD *standard_exts[] = {
     &v3_freshest_crl,
     &v3_ct_scts[0],
     &v3_ct_scts[1],
+    &v3_subject_alt_public_key_info,
+    &v3_alt_sigval,
+    &v3_alt_sigalg,
 };
 
 /* Number of standard extensions */
diff --git a/crypto/x509v3/v3_qr.c b/crypto/x509v3/v3_qr.c
new file mode 100644
index 0000000..edacc89
--- /dev/null
+++ b/crypto/x509v3/v3_qr.c
@@ -0,0 +1,234 @@
+/** @file v3_qr.c
+ *
+ * Isara Corporation Quantum Safe EST Proprietary Software License
+ * Statement
+ *
+ * LICENSE AGREEMENT: The Product(s) that reference this license include
+ * embedded proprietary software and software “plug-ins” in source code or
+ * object code or both (the “Software”) and accompanying materials (the
+ * “Documentation”) that are subject to the license terms and restrictions
+ * described below (the “License"). If you do not agree to the License
+ * terms, do not use the Product, notify Isara Corporation (“Isara”) by
+ * electronic mail at sales@isara.com and erase any copies of the Product
+ * in your possession. If you are entering into this License on behalf of
+ * a company or other legal entity, you represent that you have the right
+ * to bind that entity to all terms, and “you” refers both to you
+ * personally and such entity.
+ *
+ * USE AND DISTRIBUTION: You may use the Software only in the form and in
+ * the Product(s) delivered to you for the purposes of integration,
+ * development and testing with your own products and/or as part of a
+ * monitoring and/or control group beta test with third parties that agree
+ * in writing to be bound by the terms of this License.
+ *
+ * ADDITIONAL RESTRICTIONS: You shall not use, modify, reproduce, reverse
+ * engineer, disassemble, decompile or otherwise attempt to derive source
+ * code from the Software (except to the extent that such limitations may
+ * not be prohibited by law), sublicense, or distribute the Software or
+ * Documentation other than as permitted by this License. You shall not
+ * remove any proprietary notices, labels or marks on the Product(s) “ZIP
+ * file”, Software or Documentation. No license is granted to use or
+ * reproduce any Isara trademarks.
+ *
+ * OWNERSHIP AND NOTICE: Except for the limited rights granted above,
+ * Isara and its suppliers retain all right, title and interest in and to
+ * the Software and Documentation, including copyrights, patents, trade
+ * secrets and other proprietary rights. Certain components of the
+ * Software that are subject to open source and third party licenses, the
+ * terms and conditions of which can found at https://github.com/cisco and
+ * select the applicable hash-sigs or libest license filed on the Github
+ * repository. If you require additional guidance, notify sales@isara.com
+ * for assistance. As a condition of the License, you agree to comply with
+ * all of the foregoing open source and third party license terms. Unless
+ * required by applicable law, such components are provided on an ‘AS IS’
+ * BASIS, WITHOUT EXPRESS OR IMPLIED WARRANTIES OR CONDITIONS OF ANY KIND.
+ *
+ * WARRANTY DISCLAIMER: THE SOFTWARE AND DOCUMENTATION ARE PROVIDED TO YOU
+ * "AS IS", AND YOU ASSUME THE ENTIRE RISK OF THEIR USE. ISARA AND ITS
+ * SUPPLIERS MAKES NO WARRANTIES OR CONDITIONS, EXPRESS, IMPLIED,
+ * STATUTORY OR IN ANY COMMUNICATION WITH YOU, AND ISARA CORPORATION
+ * EXPRESSLY DISCLAIMS ANY IMPLIED WARRANTIES OF MERCHANTABILITY, FITNESS
+ * FOR A PARTICULAR PURPOSE OR NONINFRINGEMENT WITH RESPECT TO THE
+ * SOFTWARE (INCLUDING ANY MODIFICATIONS MADE THERETO BY ANY PERSON
+ * WHETHER OR NOT AN EMPLOYEE OR CONTRACTOR OF ISARA) OR DOCUMENTATION
+ * PROVIDED TO YOU. ISARA EMPLOYEES AND OTHER PERSONNEL ARE NOT AUTHORIZED
+ * TO MAKE ANY WARRANTY THAT IS INCONSISTENT WITH THIS DISCLAIMER.
+ *
+ * LIMITATION OF LIABILITY: IN NO EVENT WILL ISARA OR ITS SUPPLIERS AND
+ * SUPPLIERS BE LIABLE FOR LOSS OF DATA, LOST PROFITS, COST OF COVER, OR
+ * OTHER SPECIAL, INCIDENTAL, PUNITIVE, CONSEQUENTIAL, OR INDIRECT DAMAGES
+ * ARISING FROM USE OF THE SOFTWARE OR DOCUMENTATION, HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, AND REGARDLESS OF WHETHER ISARA OR ITS
+ * SUPPLIERS HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  ISARA
+ * AND ITS SUPPLIERS BEAR NO LIABILITY FOR ANY PROGRAMS OR DATA STORED IN
+ * OR USED WITH THIS PRODUCT, INCLUDING THE COST OF RECOVERING SUCH
+ * PROGRAMS OR DATA.
+ *
+ * Copyright (c) 2017 ISARA Corporation. All Rights Reserved. This file
+ * contains Proprietary information of Isara Corporation. Unauthorized
+ * copying or use of this file via any medium is strictly prohibited.
+ * Written by Jerry Sui, jerry.sui@isara.com; Daniel Van Geest,
+ * daniel.vangeest@isara.com, December, 2017.
+ */
+
+#include "cryptlib.h"
+#include <openssl/asn1.h>
+#include <openssl/asn1t.h>
+#include <openssl/x509v3.h>
+
+/* ====================================================================
+ * General output.
+ * ====================================================================
+ */
+static int bitstring_print(BIO *bp, const char *prefix, const ASN1_BIT_STRING *str, int off)
+{
+    int n = 0;
+    int i = 0;
+
+    if (str == NULL || str->length == 0) {
+        return 1;
+    }
+
+    if (BIO_printf(bp, "%s", prefix) <= 0) {
+        return 0;
+    }
+
+    n = str->length;
+    for (i = 0; i < n; i++) {
+        if ((i % 15) == 0) {
+            if (BIO_puts(bp, "\n") <= 0 || !BIO_indent(bp, off + 4, 128))
+                return 0;
+        }
+
+        if (BIO_printf(bp, "%02x%s", str->data[i], ((i + 1) == n) ? "" : ":")
+            <= 0) {
+            return 0;
+        }
+    }
+
+    if (BIO_write(bp, "\n", 1) <= 0) {
+        return 0;
+    }
+
+    return 1;
+}
+
+/* ====================================================================
+ * ALT Public Key Extension.
+ * ====================================================================
+ */
+static int i2r_SUBJECT_ALT_PUBLIC_KEY_INFO(X509V3_EXT_METHOD *method,
+                                 SUBJECT_ALT_PUBLIC_KEY_INFO *altpub, BIO *out,
+                                 int indent);
+
+const X509V3_EXT_METHOD v3_subject_alt_public_key_info = {
+    NID_subj_alt_pub_key,
+    X509V3_EXT_MULTILINE, ASN1_ITEM_ref(SUBJECT_ALT_PUBLIC_KEY_INFO),
+    0, 0, 0, 0,
+    0, 0, 0, 0,
+    (X509V3_EXT_I2R) i2r_SUBJECT_ALT_PUBLIC_KEY_INFO, NULL,
+    NULL
+};
+
+/* This is the same as the definition of the X509 subject public key in x_pubkey.c  */
+ASN1_SEQUENCE(SUBJECT_ALT_PUBLIC_KEY_INFO) = {
+        ASN1_SIMPLE(SUBJECT_ALT_PUBLIC_KEY_INFO, algor, X509_ALGOR),
+        ASN1_SIMPLE(SUBJECT_ALT_PUBLIC_KEY_INFO, public_key, ASN1_BIT_STRING)
+} ASN1_SEQUENCE_END(SUBJECT_ALT_PUBLIC_KEY_INFO)
+
+IMPLEMENT_ASN1_FUNCTIONS(SUBJECT_ALT_PUBLIC_KEY_INFO)
+
+static int i2r_SUBJECT_ALT_PUBLIC_KEY_INFO(X509V3_EXT_METHOD *method,
+                                 SUBJECT_ALT_PUBLIC_KEY_INFO *alt_pub, BIO *out,
+                                 int indent)
+{
+
+    X509_PUBKEY *x509_pub = NULL;
+    EVP_PKEY * pkey_pub = NULL;
+    int ret = 0;
+
+    x509_pub = X509_PUBKEY_new();
+    if (x509_pub == NULL) {
+        goto end;
+    }
+
+    /* Prevent the leaking of memory */
+    X509_ALGOR_free(x509_pub->algor);
+    ASN1_BIT_STRING_free(x509_pub->public_key);
+
+    x509_pub->algor = alt_pub->algor;
+    x509_pub->public_key = alt_pub->public_key;
+
+    pkey_pub = X509_PUBKEY_get(x509_pub);
+    if (pkey_pub == NULL) {
+        goto end;
+    }
+    BIO_indent(out, indent, 128);
+    BIO_printf(out, "%s\n", OBJ_nid2ln(OBJ_obj2nid(alt_pub->algor->algorithm)));
+    EVP_PKEY_print_public(out, pkey_pub, indent, NULL);
+    ret = 1;
+
+end:
+    if (pkey_pub)
+        EVP_PKEY_free(pkey_pub);
+    if(x509_pub) {
+        /* Prevent a double free */
+        x509_pub->algor = NULL;
+        x509_pub->public_key = NULL;
+        X509_PUBKEY_free(x509_pub);
+    }
+
+    return ret;
+}
+
+/* ====================================================================
+ * ALT Signature Value Extension.
+ * ====================================================================
+ */
+static int i2r_ALT_SIGNATURE_VALUE(X509V3_EXT_METHOD *method,
+                                 ASN1_BIT_STRING *signature, BIO *out,
+                                 int indent);
+
+const X509V3_EXT_METHOD v3_alt_sigval = {
+    NID_alt_sigval, 0, ASN1_ITEM_ref(ASN1_BIT_STRING),
+    0, 0, 0, 0,
+    0, 0, 0, 0,
+    (X509V3_EXT_I2R)i2r_ALT_SIGNATURE_VALUE, NULL,
+    NULL
+};
+
+static int i2r_ALT_SIGNATURE_VALUE(X509V3_EXT_METHOD *method,
+                                 ASN1_BIT_STRING *signature, BIO *out,
+                                 int indent)
+{
+    BIO_printf(out, "%*s", indent, "");
+    if (signature) {
+        bitstring_print(out, "Signature: ", signature, indent);
+    }
+    return 1;
+}
+
+/* ====================================================================
+ * ALT Signature Algorithm Extension.
+ * ====================================================================
+ */
+static int i2r_ALT_SIGALG(X509V3_EXT_METHOD *method,
+                                 X509_ALGOR *sigalg, BIO *out,
+                                 int indent);
+
+const X509V3_EXT_METHOD v3_alt_sigalg = {
+    NID_alt_sigalg, 0, ASN1_ITEM_ref(X509_ALGOR),
+    0, 0, 0, 0,
+    0, 0, 0, 0,
+    (X509V3_EXT_I2R)i2r_ALT_SIGALG, NULL,
+    NULL
+};
+
+static int i2r_ALT_SIGALG(X509V3_EXT_METHOD *method,
+                                 X509_ALGOR *sigalg, BIO *out,
+                                 int indent)
+{
+    BIO_indent(out, indent, 128);
+    BIO_printf(out, "%s\n", OBJ_nid2ln(OBJ_obj2nid(sigalg->algorithm)));
+    return 1;
+}
diff --git a/crypto/x509v3/x509v3.h b/crypto/x509v3/x509v3.h
index f5c6156..170a021 100644
--- a/crypto/x509v3/x509v3.h
+++ b/crypto/x509v3/x509v3.h
@@ -154,6 +154,11 @@ DECLARE_STACK_OF(X509V3_EXT_METHOD)
 
 typedef BIT_STRING_BITNAME ENUMERATED_NAMES;
 
+typedef struct SUBJECT_ALT_PUBLIC_KEY_INFO_st {
+    X509_ALGOR *algor;
+    ASN1_BIT_STRING *public_key;
+} SUBJECT_ALT_PUBLIC_KEY_INFO;
+
 typedef struct BASIC_CONSTRAINTS_st {
     int ca;
     ASN1_INTEGER *pathlen;
@@ -503,6 +508,8 @@ typedef struct x509_purpose_st {
 
 DECLARE_STACK_OF(X509_PURPOSE)
 
+DECLARE_ASN1_FUNCTIONS(SUBJECT_ALT_PUBLIC_KEY_INFO)
+
 DECLARE_ASN1_FUNCTIONS(BASIC_CONSTRAINTS)
 
 DECLARE_ASN1_FUNCTIONS(SXNET)
diff --git a/ssl/Makefile b/ssl/Makefile
index 6c59eb7..b8df42b 100644
--- a/ssl/Makefile
+++ b/ssl/Makefile
@@ -551,26 +551,27 @@ s3_cbc.o: ../include/openssl/x509.h ../include/openssl/x509_vfy.h s3_cbc.c
 s3_cbc.o: ssl_locl.h
 s3_clnt.o: ../e_os.h ../include/openssl/asn1.h ../include/openssl/bio.h
 s3_clnt.o: ../include/openssl/bn.h ../include/openssl/buffer.h
-s3_clnt.o: ../include/openssl/comp.h ../include/openssl/crypto.h
-s3_clnt.o: ../include/openssl/dh.h ../include/openssl/dsa.h
-s3_clnt.o: ../include/openssl/dtls1.h ../include/openssl/e_os2.h
-s3_clnt.o: ../include/openssl/ec.h ../include/openssl/ecdh.h
-s3_clnt.o: ../include/openssl/ecdsa.h ../include/openssl/engine.h
-s3_clnt.o: ../include/openssl/err.h ../include/openssl/evp.h
-s3_clnt.o: ../include/openssl/hmac.h ../include/openssl/hss.h
-s3_clnt.o: ../include/openssl/kssl.h ../include/openssl/lhash.h
-s3_clnt.o: ../include/openssl/md5.h ../include/openssl/obj_mac.h
-s3_clnt.o: ../include/openssl/objects.h ../include/openssl/opensslconf.h
-s3_clnt.o: ../include/openssl/opensslv.h ../include/openssl/ossl_typ.h
-s3_clnt.o: ../include/openssl/pem.h ../include/openssl/pem2.h
-s3_clnt.o: ../include/openssl/pkcs7.h ../include/openssl/pqueue.h
-s3_clnt.o: ../include/openssl/rand.h ../include/openssl/rsa.h
-s3_clnt.o: ../include/openssl/safestack.h ../include/openssl/sha.h
-s3_clnt.o: ../include/openssl/srtp.h ../include/openssl/ssl.h
-s3_clnt.o: ../include/openssl/ssl2.h ../include/openssl/ssl23.h
-s3_clnt.o: ../include/openssl/ssl3.h ../include/openssl/stack.h
-s3_clnt.o: ../include/openssl/symhacks.h ../include/openssl/tls1.h
-s3_clnt.o: ../include/openssl/x509.h ../include/openssl/x509_vfy.h kssl_lcl.h
+s3_clnt.o: ../include/openssl/comp.h ../include/openssl/conf.h
+s3_clnt.o: ../include/openssl/crypto.h ../include/openssl/dh.h
+s3_clnt.o: ../include/openssl/dsa.h ../include/openssl/dtls1.h
+s3_clnt.o: ../include/openssl/e_os2.h ../include/openssl/ec.h
+s3_clnt.o: ../include/openssl/ecdh.h ../include/openssl/ecdsa.h
+s3_clnt.o: ../include/openssl/engine.h ../include/openssl/err.h
+s3_clnt.o: ../include/openssl/evp.h ../include/openssl/hmac.h
+s3_clnt.o: ../include/openssl/hss.h ../include/openssl/kssl.h
+s3_clnt.o: ../include/openssl/lhash.h ../include/openssl/md5.h
+s3_clnt.o: ../include/openssl/obj_mac.h ../include/openssl/objects.h
+s3_clnt.o: ../include/openssl/opensslconf.h ../include/openssl/opensslv.h
+s3_clnt.o: ../include/openssl/ossl_typ.h ../include/openssl/pem.h
+s3_clnt.o: ../include/openssl/pem2.h ../include/openssl/pkcs7.h
+s3_clnt.o: ../include/openssl/pqueue.h ../include/openssl/rand.h
+s3_clnt.o: ../include/openssl/rsa.h ../include/openssl/safestack.h
+s3_clnt.o: ../include/openssl/sha.h ../include/openssl/srtp.h
+s3_clnt.o: ../include/openssl/ssl.h ../include/openssl/ssl2.h
+s3_clnt.o: ../include/openssl/ssl23.h ../include/openssl/ssl3.h
+s3_clnt.o: ../include/openssl/stack.h ../include/openssl/symhacks.h
+s3_clnt.o: ../include/openssl/tls1.h ../include/openssl/x509.h
+s3_clnt.o: ../include/openssl/x509_vfy.h ../include/openssl/x509v3.h kssl_lcl.h
 s3_clnt.o: s3_clnt.c ssl_locl.h
 s3_enc.o: ../e_os.h ../include/openssl/asn1.h ../include/openssl/bio.h
 s3_enc.o: ../include/openssl/buffer.h ../include/openssl/comp.h
@@ -840,23 +841,24 @@ ssl_lib.o: ../include/openssl/x509_vfy.h ../include/openssl/x509v3.h kssl_lcl.h
 ssl_lib.o: ssl_lib.c ssl_locl.h
 ssl_rsa.o: ../e_os.h ../include/openssl/asn1.h ../include/openssl/bio.h
 ssl_rsa.o: ../include/openssl/buffer.h ../include/openssl/comp.h
-ssl_rsa.o: ../include/openssl/crypto.h ../include/openssl/dsa.h
-ssl_rsa.o: ../include/openssl/dtls1.h ../include/openssl/e_os2.h
-ssl_rsa.o: ../include/openssl/ec.h ../include/openssl/ecdh.h
-ssl_rsa.o: ../include/openssl/ecdsa.h ../include/openssl/err.h
-ssl_rsa.o: ../include/openssl/evp.h ../include/openssl/hmac.h
-ssl_rsa.o: ../include/openssl/kssl.h ../include/openssl/lhash.h
-ssl_rsa.o: ../include/openssl/obj_mac.h ../include/openssl/objects.h
-ssl_rsa.o: ../include/openssl/opensslconf.h ../include/openssl/opensslv.h
-ssl_rsa.o: ../include/openssl/ossl_typ.h ../include/openssl/pem.h
-ssl_rsa.o: ../include/openssl/pem2.h ../include/openssl/pkcs7.h
-ssl_rsa.o: ../include/openssl/pqueue.h ../include/openssl/rsa.h
-ssl_rsa.o: ../include/openssl/safestack.h ../include/openssl/sha.h
-ssl_rsa.o: ../include/openssl/srtp.h ../include/openssl/ssl.h
-ssl_rsa.o: ../include/openssl/ssl2.h ../include/openssl/ssl23.h
-ssl_rsa.o: ../include/openssl/ssl3.h ../include/openssl/stack.h
-ssl_rsa.o: ../include/openssl/symhacks.h ../include/openssl/tls1.h
-ssl_rsa.o: ../include/openssl/x509.h ../include/openssl/x509_vfy.h ssl_locl.h
+ssl_rsa.o: ../include/openssl/conf.h ../include/openssl/crypto.h
+ssl_rsa.o: ../include/openssl/dsa.h ../include/openssl/dtls1.h
+ssl_rsa.o: ../include/openssl/e_os2.h ../include/openssl/ec.h
+ssl_rsa.o: ../include/openssl/ecdh.h ../include/openssl/ecdsa.h
+ssl_rsa.o: ../include/openssl/err.h ../include/openssl/evp.h
+ssl_rsa.o: ../include/openssl/hmac.h ../include/openssl/kssl.h
+ssl_rsa.o: ../include/openssl/lhash.h ../include/openssl/obj_mac.h
+ssl_rsa.o: ../include/openssl/objects.h ../include/openssl/opensslconf.h
+ssl_rsa.o: ../include/openssl/opensslv.h ../include/openssl/ossl_typ.h
+ssl_rsa.o: ../include/openssl/pem.h ../include/openssl/pem2.h
+ssl_rsa.o: ../include/openssl/pkcs7.h ../include/openssl/pqueue.h
+ssl_rsa.o: ../include/openssl/rsa.h ../include/openssl/safestack.h
+ssl_rsa.o: ../include/openssl/sha.h ../include/openssl/srtp.h
+ssl_rsa.o: ../include/openssl/ssl.h ../include/openssl/ssl2.h
+ssl_rsa.o: ../include/openssl/ssl23.h ../include/openssl/ssl3.h
+ssl_rsa.o: ../include/openssl/stack.h ../include/openssl/symhacks.h
+ssl_rsa.o: ../include/openssl/tls1.h ../include/openssl/x509.h
+ssl_rsa.o: ../include/openssl/x509_vfy.h ../include/openssl/x509v3.h ssl_locl.h
 ssl_rsa.o: ssl_rsa.c
 ssl_sess.o: ../e_os.h ../include/openssl/asn1.h ../include/openssl/bio.h
 ssl_sess.o: ../include/openssl/buffer.h ../include/openssl/comp.h
diff --git a/ssl/s3_clnt.c b/ssl/s3_clnt.c
index b76c943..5a2d380 100644
--- a/ssl/s3_clnt.c
+++ b/ssl/s3_clnt.c
@@ -147,6 +147,77 @@
  * OTHER ENTITY BASED ON INFRINGEMENT OF INTELLECTUAL PROPERTY RIGHTS OR
  * OTHERWISE.
  */
+/* ====================================================================
+ * Isara Corporation Quantum Safe EST Proprietary Software License
+ * Statement
+ *
+ * LICENSE AGREEMENT: The Product(s) that reference this license include
+ * embedded proprietary software and software “plug-ins” in source code or
+ * object code or both (the “Software”) and accompanying materials (the
+ * “Documentation”) that are subject to the license terms and restrictions
+ * described below (the “License"). If you do not agree to the License
+ * terms, do not use the Product, notify Isara Corporation (“Isara”) by
+ * electronic mail at sales@isara.com and erase any copies of the Product
+ * in your possession. If you are entering into this License on behalf of
+ * a company or other legal entity, you represent that you have the right
+ * to bind that entity to all terms, and “you” refers both to you
+ * personally and such entity.
+ *
+ * USE AND DISTRIBUTION: You may use the Software only in the form and in
+ * the Product(s) delivered to you for the purposes of integration,
+ * development and testing with your own products and/or as part of a
+ * monitoring and/or control group beta test with third parties that agree
+ * in writing to be bound by the terms of this License.
+ *
+ * ADDITIONAL RESTRICTIONS: You shall not use, modify, reproduce, reverse
+ * engineer, disassemble, decompile or otherwise attempt to derive source
+ * code from the Software (except to the extent that such limitations may
+ * not be prohibited by law), sublicense, or distribute the Software or
+ * Documentation other than as permitted by this License. You shall not
+ * remove any proprietary notices, labels or marks on the Product(s) “ZIP
+ * file”, Software or Documentation. No license is granted to use or
+ * reproduce any Isara trademarks.
+ *
+ * OWNERSHIP AND NOTICE: Except for the limited rights granted above,
+ * Isara and its suppliers retain all right, title and interest in and to
+ * the Software and Documentation, including copyrights, patents, trade
+ * secrets and other proprietary rights. Certain components of the
+ * Software that are subject to open source and third party licenses, the
+ * terms and conditions of which can found at https://github.com/cisco and
+ * select the applicable hash-sigs or libest license filed on the Github
+ * repository. If you require additional guidance, notify sales@isara.com
+ * for assistance. As a condition of the License, you agree to comply with
+ * all of the foregoing open source and third party license terms. Unless
+ * required by applicable law, such components are provided on an ‘AS IS’
+ * BASIS, WITHOUT EXPRESS OR IMPLIED WARRANTIES OR CONDITIONS OF ANY KIND.
+ *
+ * WARRANTY DISCLAIMER: THE SOFTWARE AND DOCUMENTATION ARE PROVIDED TO YOU
+ * "AS IS", AND YOU ASSUME THE ENTIRE RISK OF THEIR USE. ISARA AND ITS
+ * SUPPLIERS MAKES NO WARRANTIES OR CONDITIONS, EXPRESS, IMPLIED,
+ * STATUTORY OR IN ANY COMMUNICATION WITH YOU, AND ISARA CORPORATION
+ * EXPRESSLY DISCLAIMS ANY IMPLIED WARRANTIES OF MERCHANTABILITY, FITNESS
+ * FOR A PARTICULAR PURPOSE OR NONINFRINGEMENT WITH RESPECT TO THE
+ * SOFTWARE (INCLUDING ANY MODIFICATIONS MADE THERETO BY ANY PERSON
+ * WHETHER OR NOT AN EMPLOYEE OR CONTRACTOR OF ISARA) OR DOCUMENTATION
+ * PROVIDED TO YOU. ISARA EMPLOYEES AND OTHER PERSONNEL ARE NOT AUTHORIZED
+ * TO MAKE ANY WARRANTY THAT IS INCONSISTENT WITH THIS DISCLAIMER.
+ *
+ * LIMITATION OF LIABILITY: IN NO EVENT WILL ISARA OR ITS SUPPLIERS AND
+ * SUPPLIERS BE LIABLE FOR LOSS OF DATA, LOST PROFITS, COST OF COVER, OR
+ * OTHER SPECIAL, INCIDENTAL, PUNITIVE, CONSEQUENTIAL, OR INDIRECT DAMAGES
+ * ARISING FROM USE OF THE SOFTWARE OR DOCUMENTATION, HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, AND REGARDLESS OF WHETHER ISARA OR ITS
+ * SUPPLIERS HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  ISARA
+ * AND ITS SUPPLIERS BEAR NO LIABILITY FOR ANY PROGRAMS OR DATA STORED IN
+ * OR USED WITH THIS PRODUCT, INCLUDING THE COST OF RECOVERING SUCH
+ * PROGRAMS OR DATA.
+ *
+ * Copyright (c) 2017 ISARA Corporation. All Rights Reserved. This file
+ * contains Proprietary information of Isara Corporation. Unauthorized
+ * copying or use of this file via any medium is strictly prohibited.
+ * Written by Jerry Sui, jerry.sui@isara.com; Daniel Van Geest,
+ * daniel.vangeest@isara.com, December, 2017.
+ */
 
 #include <stdio.h>
 #include "ssl_locl.h"
@@ -156,6 +227,7 @@
 #include <openssl/objects.h>
 #include <openssl/evp.h>
 #include <openssl/md5.h>
+#include <openssl/x509v3.h>
 #ifdef OPENSSL_FIPS
 # include <openssl/fips.h>
 #endif
@@ -170,11 +242,13 @@
 # include <openssl/engine.h>
 #endif
 
+
 static int ca_dn_cmp(const X509_NAME *const *a, const X509_NAME *const *b);
 #ifndef OPENSSL_NO_TLSEXT
 static int ssl3_check_finished(SSL *s);
 #endif
 
+
 #ifndef OPENSSL_NO_SSL3_METHOD
 static const SSL_METHOD *ssl3_get_client_method(int ver)
 {
@@ -1329,12 +1403,30 @@ int ssl3_get_server_certificate(SSL *s)
     if (need_cert) {
         int exp_idx = ssl_cipher_get_cert_index(s->s3->tmp.new_cipher);
         if (exp_idx >= 0 && i != exp_idx) {
-            x = NULL;
-            al = SSL_AD_ILLEGAL_PARAMETER;
-            SSLerr(SSL_F_SSL3_GET_SERVER_CERTIFICATE,
-                   SSL_R_WRONG_CERTIFICATE_TYPE);
-            goto f_err;
+            EVP_PKEY_free(pkey);
+
+            /* Get the QS ALT PKEY. */
+            pkey = SSL_get_alt_pubkey(x);
+            if (pkey == NULL) {
+                x = NULL;
+                al = SSL_AD_ILLEGAL_PARAMETER;
+                SSLerr(SSL_F_SSL3_GET_SERVER_CERTIFICATE,
+                       SSL_R_WRONG_CERTIFICATE_TYPE);
+                goto f_err;
+            }
+
+            i = ssl_cert_type(NULL, pkey);
+            if (i != exp_idx) {
+                x = NULL;
+                al = SSL_AD_ILLEGAL_PARAMETER;
+                SSLerr(SSL_F_SSL3_GET_SERVER_CERTIFICATE,
+                       SSL_R_WRONG_CERTIFICATE_TYPE);
+                goto f_err;
+            }
+
+            sc->peer_pkeys[i].is_mpka_cert = 1;
         }
+
         sc->peer_cert_type = i;
         CRYPTO_add(&x->references, 1, CRYPTO_LOCK_X509);
         /*
@@ -1925,7 +2017,11 @@ int ssl3_get_key_exchange(SSL *s)
 # endif
 # ifndef OPENSSL_NO_HSS
         else if (alg_a & SSL_aHSS)
-            pkey = X509_get_pubkey(s->session->sess_cert->peer_pkeys[SSL_PKEY_HSS].x509);
+            if (s->session->sess_cert->peer_pkeys[SSL_PKEY_HSS].is_mpka_cert) {
+                pkey = SSL_get_alt_pubkey(s->session->sess_cert->peer_pkeys[SSL_PKEY_HSS].x509);
+            } else {
+                pkey = X509_get_pubkey(s->session->sess_cert->peer_pkeys[SSL_PKEY_HSS].x509);
+            }
 # endif
 # ifndef OPENSSL_NO_ECDSA
         else if (alg_a & SSL_aECDSA)
@@ -2986,6 +3082,7 @@ int ssl3_send_client_key_exchange(SSL *s)
                 /* copy the point */
                 memcpy((unsigned char *)p, encodedPoint, n);
                 /* increment n to account for length field */
+
                 n += 1;
             }
 
@@ -3291,7 +3388,37 @@ int ssl3_send_client_verify(SSL *s)
         if (SSL_USE_SIGALGS(s)) {
             long hdatalen = 0;
             void *hdata;
-            const EVP_MD *md = s->cert->key->digest;
+            const EVP_MD *md = NULL;
+
+            if (s->cert->key->is_mpka_cert == 1 && s->cert->peer_mpkac_support == 1) {
+                /*
+                 * If client cert is an MPKAC, and the peer supports MPKAC,
+                 * then the signature shall be generated with the alternative key
+                 * (i.e., QS private key).
+                 */
+
+                int i = 0;
+                EVP_PKEY *alt_pub_key =  SSL_get_alt_pubkey(s->cert->key->x509);
+                if (alt_pub_key == NULL) {
+                    SSLerr(SSL_F_SSL3_SEND_CLIENT_VERIFY, ERR_R_INTERNAL_ERROR);
+                    goto err;
+                }
+
+                i = ssl_cert_type(s->cert->key->x509, alt_pub_key);
+                if (i < 0 || s->cert->pkeys[i].privatekey == NULL) {
+                    SSLerr(SSL_F_SSL3_SEND_CLIENT_VERIFY, ERR_R_INTERNAL_ERROR);
+                    EVP_PKEY_free(alt_pub_key);
+                    goto err;
+                }
+
+                pkey = s->cert->pkeys[i].privatekey;
+                md = s->cert->pkeys[i].digest;
+
+                EVP_PKEY_free(alt_pub_key);
+            } else {
+                md = s->cert->key->digest;
+            }
+
             hdatalen = BIO_get_mem_data(s->s3->handshake_buffer, &hdata);
             if (hdatalen <= 0 || !tls12_get_sigandhash(p, pkey, md)) {
                 SSLerr(SSL_F_SSL3_SEND_CLIENT_VERIFY, ERR_R_INTERNAL_ERROR);
@@ -3563,41 +3690,70 @@ int ssl3_check_cert_and_algorithm(SSL *s)
     /* This is the passed certificate */
 
     idx = sc->peer_cert_type;
-#ifndef OPENSSL_NO_ECDH
-    if (idx == SSL_PKEY_ECC) {
-        if (ssl_check_srvr_ecc_cert_and_alg(sc->peer_pkeys[idx].x509, s) == 0) {
-            /* check failed */
-            SSLerr(SSL_F_SSL3_CHECK_CERT_AND_ALGORITHM, SSL_R_BAD_ECC_CERT);
-            goto f_err;
-        } else {
-            return 1;
-        }
-    } else if (alg_a & SSL_aECDSA) {
-        SSLerr(SSL_F_SSL3_CHECK_CERT_AND_ALGORITHM,
-               SSL_R_MISSING_ECDSA_SIGNING_CERT);
-        goto f_err;
-    } else if (alg_k & (SSL_kECDHr | SSL_kECDHe)) {
-        SSLerr(SSL_F_SSL3_CHECK_CERT_AND_ALGORITHM, SSL_R_MISSING_ECDH_CERT);
-        goto f_err;
-    }
-#endif
+
     pkey = X509_get_pubkey(sc->peer_pkeys[idx].x509);
     pkey_bits = EVP_PKEY_bits(pkey);
     i = X509_certificate_type(sc->peer_pkeys[idx].x509, pkey);
     EVP_PKEY_free(pkey);
 
-    /* Check that we have a certificate if we require one */
-    if ((alg_a & SSL_aRSA) && !has_bits(i, EVP_PK_RSA | EVP_PKT_SIGN)) {
-        SSLerr(SSL_F_SSL3_CHECK_CERT_AND_ALGORITHM,
-               SSL_R_MISSING_RSA_SIGNING_CERT);
-        goto f_err;
-    }
+    if (sc->peer_pkeys[idx].is_mpka_cert) {
+        EVP_PKEY *qs_pkey = SSL_get_alt_pubkey(sc->peer_pkeys[idx].x509);
+        if (qs_pkey == NULL) {
+            SSLerr(SSL_F_SSL3_CHECK_CERT_AND_ALGORITHM,
+                   SSL_R_NO_PUBLICKEY);
+            goto f_err;
+        }
+
+#ifndef OPENSSL_NO_HSS
+        if (alg_a & SSL_aHSS) {
+            if (qs_pkey->type != EVP_PKEY_HSS) {
+                EVP_PKEY_free(qs_pkey);
+                SSLerr(SSL_F_SSL3_CHECK_CERT_AND_ALGORITHM,
+                       SSL_R_MISSING_HSS_SIGNING_CERT);
+                goto f_err;
+            }
+        } else
+#endif
+        {
+            EVP_PKEY_free(qs_pkey);
+            SSLerr(SSL_F_SSL3_CHECK_CERT_AND_ALGORITHM,
+                   SSL_R_WRONG_SIGNATURE_TYPE);
+            goto f_err;
+        }
+
+        EVP_PKEY_free(qs_pkey);
+    } else {
+#ifndef OPENSSL_NO_ECDH
+        if (idx == SSL_PKEY_ECC) {
+            if (ssl_check_srvr_ecc_cert_and_alg(sc->peer_pkeys[idx].x509, s) == 0) {
+                /* check failed */
+                SSLerr(SSL_F_SSL3_CHECK_CERT_AND_ALGORITHM, SSL_R_BAD_ECC_CERT);
+                goto f_err;
+            } else {
+                return 1;
+            }
+        } else if (alg_a & SSL_aECDSA) {
+            SSLerr(SSL_F_SSL3_CHECK_CERT_AND_ALGORITHM,
+                   SSL_R_MISSING_ECDSA_SIGNING_CERT);
+            goto f_err;
+        } else if (alg_k & (SSL_kECDHr | SSL_kECDHe)) {
+            SSLerr(SSL_F_SSL3_CHECK_CERT_AND_ALGORITHM, SSL_R_MISSING_ECDH_CERT);
+            goto f_err;
+        }
+#endif
+
+        /* Check that we have a certificate if we require one */
+        if ((alg_a & SSL_aRSA) && !has_bits(i, EVP_PK_RSA | EVP_PKT_SIGN)) {
+            SSLerr(SSL_F_SSL3_CHECK_CERT_AND_ALGORITHM,
+                   SSL_R_MISSING_RSA_SIGNING_CERT);
+            goto f_err;
+        }
 #ifndef OPENSSL_NO_DSA
-    else if ((alg_a & SSL_aDSS) && !has_bits(i, EVP_PK_DSA | EVP_PKT_SIGN)) {
-        SSLerr(SSL_F_SSL3_CHECK_CERT_AND_ALGORITHM,
-               SSL_R_MISSING_DSA_SIGNING_CERT);
-        goto f_err;
-    }
+        else if ((alg_a & SSL_aDSS) && !has_bits(i, EVP_PK_DSA | EVP_PKT_SIGN)) {
+            SSLerr(SSL_F_SSL3_CHECK_CERT_AND_ALGORITHM,
+                   SSL_R_MISSING_DSA_SIGNING_CERT);
+            goto f_err;
+        }
 #endif
 #ifndef OPENSSL_NO_HSS
     else if ((alg_a & SSL_aHSS) && !has_bits(i, EVP_PK_HSS | EVP_PKT_SIGN)) {
@@ -3606,6 +3762,7 @@ int ssl3_check_cert_and_algorithm(SSL *s)
         goto f_err;
     }
 #endif
+    }
 
 #ifndef OPENSSL_NO_RSA
     if (alg_k & SSL_kRSA) {
diff --git a/ssl/s3_srvr.c b/ssl/s3_srvr.c
index 6f7c783..25da6d6 100644
--- a/ssl/s3_srvr.c
+++ b/ssl/s3_srvr.c
@@ -147,6 +147,77 @@
  * OTHER ENTITY BASED ON INFRINGEMENT OF INTELLECTUAL PROPERTY RIGHTS OR
  * OTHERWISE.
  */
+/* ====================================================================
+ * Isara Corporation Quantum Safe EST Proprietary Software License
+ * Statement
+ *
+ * LICENSE AGREEMENT: The Product(s) that reference this license include
+ * embedded proprietary software and software “plug-ins” in source code or
+ * object code or both (the “Software”) and accompanying materials (the
+ * “Documentation”) that are subject to the license terms and restrictions
+ * described below (the “License"). If you do not agree to the License
+ * terms, do not use the Product, notify Isara Corporation (“Isara”) by
+ * electronic mail at sales@isara.com and erase any copies of the Product
+ * in your possession. If you are entering into this License on behalf of
+ * a company or other legal entity, you represent that you have the right
+ * to bind that entity to all terms, and “you” refers both to you
+ * personally and such entity.
+ *
+ * USE AND DISTRIBUTION: You may use the Software only in the form and in
+ * the Product(s) delivered to you for the purposes of integration,
+ * development and testing with your own products and/or as part of a
+ * monitoring and/or control group beta test with third parties that agree
+ * in writing to be bound by the terms of this License.
+ *
+ * ADDITIONAL RESTRICTIONS: You shall not use, modify, reproduce, reverse
+ * engineer, disassemble, decompile or otherwise attempt to derive source
+ * code from the Software (except to the extent that such limitations may
+ * not be prohibited by law), sublicense, or distribute the Software or
+ * Documentation other than as permitted by this License. You shall not
+ * remove any proprietary notices, labels or marks on the Product(s) “ZIP
+ * file”, Software or Documentation. No license is granted to use or
+ * reproduce any Isara trademarks.
+ *
+ * OWNERSHIP AND NOTICE: Except for the limited rights granted above,
+ * Isara and its suppliers retain all right, title and interest in and to
+ * the Software and Documentation, including copyrights, patents, trade
+ * secrets and other proprietary rights. Certain components of the
+ * Software that are subject to open source and third party licenses, the
+ * terms and conditions of which can found at https://github.com/cisco and
+ * select the applicable hash-sigs or libest license filed on the Github
+ * repository. If you require additional guidance, notify sales@isara.com
+ * for assistance. As a condition of the License, you agree to comply with
+ * all of the foregoing open source and third party license terms. Unless
+ * required by applicable law, such components are provided on an ‘AS IS’
+ * BASIS, WITHOUT EXPRESS OR IMPLIED WARRANTIES OR CONDITIONS OF ANY KIND.
+ *
+ * WARRANTY DISCLAIMER: THE SOFTWARE AND DOCUMENTATION ARE PROVIDED TO YOU
+ * "AS IS", AND YOU ASSUME THE ENTIRE RISK OF THEIR USE. ISARA AND ITS
+ * SUPPLIERS MAKES NO WARRANTIES OR CONDITIONS, EXPRESS, IMPLIED,
+ * STATUTORY OR IN ANY COMMUNICATION WITH YOU, AND ISARA CORPORATION
+ * EXPRESSLY DISCLAIMS ANY IMPLIED WARRANTIES OF MERCHANTABILITY, FITNESS
+ * FOR A PARTICULAR PURPOSE OR NONINFRINGEMENT WITH RESPECT TO THE
+ * SOFTWARE (INCLUDING ANY MODIFICATIONS MADE THERETO BY ANY PERSON
+ * WHETHER OR NOT AN EMPLOYEE OR CONTRACTOR OF ISARA) OR DOCUMENTATION
+ * PROVIDED TO YOU. ISARA EMPLOYEES AND OTHER PERSONNEL ARE NOT AUTHORIZED
+ * TO MAKE ANY WARRANTY THAT IS INCONSISTENT WITH THIS DISCLAIMER.
+ *
+ * LIMITATION OF LIABILITY: IN NO EVENT WILL ISARA OR ITS SUPPLIERS AND
+ * SUPPLIERS BE LIABLE FOR LOSS OF DATA, LOST PROFITS, COST OF COVER, OR
+ * OTHER SPECIAL, INCIDENTAL, PUNITIVE, CONSEQUENTIAL, OR INDIRECT DAMAGES
+ * ARISING FROM USE OF THE SOFTWARE OR DOCUMENTATION, HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, AND REGARDLESS OF WHETHER ISARA OR ITS
+ * SUPPLIERS HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  ISARA
+ * AND ITS SUPPLIERS BEAR NO LIABILITY FOR ANY PROGRAMS OR DATA STORED IN
+ * OR USED WITH THIS PRODUCT, INCLUDING THE COST OF RECOVERING SUCH
+ * PROGRAMS OR DATA.
+ *
+ * Copyright (c) 2017 ISARA Corporation. All Rights Reserved. This file
+ * contains Proprietary information of Isara Corporation. Unauthorized
+ * copying or use of this file via any medium is strictly prohibited.
+ * Written by Jerry Sui, jerry.sui@isara.com; Daniel Van Geest,
+ * daniel.vangeest@isara.com, December, 2017.
+ */
 
 #define REUSE_CIPHER_BUG
 #define NETSCAPE_HANG_BUG
@@ -3026,6 +3097,7 @@ int ssl3_get_cert_verify(SSL *s)
     long n;
     int type = 0, i, j;
     X509 *peer;
+    int alt_pub_key_idx = -1;
     const EVP_MD *md = NULL;
     EVP_MD_CTX mctx;
     EVP_MD_CTX_init(&mctx);
@@ -3053,10 +3125,33 @@ int ssl3_get_cert_verify(SSL *s)
         return ((int)n);
 
     peer = s->session->peer;
-    pkey = X509_get_pubkey(peer);
-    if (pkey == NULL) {
-        al = SSL_AD_INTERNAL_ERROR;
-        goto f_err;
+
+
+    /* Test if the client cert is an MPKAC. */
+    alt_pub_key_idx = X509_get_ext_by_NID(peer, NID_subj_alt_pub_key, -1);
+
+    if (alt_pub_key_idx < 0) {
+        /* Client cert is not an MPKAC. */
+        pkey = X509_get_pubkey(peer);
+        if (pkey == NULL) {
+            al = SSL_AD_INTERNAL_ERROR;
+            goto f_err;
+        }
+    } else {
+        /* Client cert is an MPKAC. */
+
+        /* Get the alternative key instead.
+         *
+         * At this point, the server knows that the client signed the cert-verify with the
+         * alternative private key, because this server is one that supports MPKAC (otherwise,
+         * this code would not be here), and has communicated this fact to the client via
+         * cert-request.
+         */
+        pkey = SSL_get_alt_pubkey(peer);
+        if (pkey == NULL) {
+            al = SSL_AD_INTERNAL_ERROR;
+            goto f_err;
+        }
     }
 
     type = X509_certificate_type(peer, pkey);
diff --git a/ssl/ssl.h b/ssl/ssl.h
index 25a80b5..fdd011a 100644
--- a/ssl/ssl.h
+++ b/ssl/ssl.h
@@ -2199,6 +2199,10 @@ int SSL_use_certificate_file(SSL *ssl, const char *file, int type);
 int SSL_CTX_use_RSAPrivateKey_file(SSL_CTX *ctx, const char *file, int type);
 int SSL_CTX_use_PrivateKey_file(SSL_CTX *ctx, const char *file, int type);
 
+/* Register the QS private key (contained in a file) corresponding
+ * to the QS certificate for the SSL context.
+ */
+int SSL_CTX_use_ALTPrivateKey_file(SSL_CTX *ctx, const char *file, int type);
 int SSL_CTX_use_certificate_file(SSL_CTX *ctx, const char *file, int type);
 /* PEM type */
 int SSL_CTX_use_certificate_chain_file(SSL_CTX *ctx, const char *file);
@@ -2276,9 +2280,18 @@ int SSL_CTX_use_RSAPrivateKey_ASN1(SSL_CTX *ctx, const unsigned char *d,
                                    long len);
 int SSL_CTX_use_PrivateKey(SSL_CTX *ctx, EVP_PKEY *pkey);
 
+/* Register the QS private key in EVP_PKEY form corresponding
+ * to the QS certificate for the SSL context.
+ */
+int SSL_CTX_use_ALTPrivateKey(SSL_CTX *ctx, EVP_PKEY *pkey);
 int SSL_CTX_use_PrivateKey_ASN1(int pk, SSL_CTX *ctx,
                                 const unsigned char *d, long len);
 
+/* Register the QS private key in ASN.1 form corresponding
+ * to the QS certificate for the SSL context.
+ */
+int SSL_CTX_use_ALTPrivateKey_ASN1(int type, SSL_CTX *ctx,
+                                const unsigned char *d, long len);
 int SSL_CTX_use_certificate(SSL_CTX *ctx, X509 *x);
 int SSL_CTX_use_certificate_ASN1(SSL_CTX *ctx, int len,
                                  const unsigned char *d);
@@ -2432,6 +2445,8 @@ X509 *SSL_get_certificate(const SSL *ssl);
  * EVP_PKEY
  */ struct evp_pkey_st *SSL_get_privatekey(const SSL *ssl);
 
+EVP_PKEY *SSL_get_alt_pubkey(X509 *x);
+
 X509 *SSL_CTX_get0_certificate(const SSL_CTX *ctx);
 EVP_PKEY *SSL_CTX_get0_privatekey(const SSL_CTX *ctx);
 
@@ -2642,6 +2657,8 @@ void ERR_load_SSL_strings(void);
 # define SSL_F_GET_SERVER_STATIC_DH_KEY                   340
 # define SSL_F_GET_SERVER_VERIFY                          110
 # define SSL_F_I2D_SSL_SESSION                            111
+# define SSL_F_IQRSSL_CERT_CHAIN_VERIFY_CB                341
+# define SSL_F_IQRSSL_CERT_VERIFY                         342
 # define SSL_F_READ_N                                     112
 # define SSL_F_REQUEST_CERTIFICATE                        113
 # define SSL_F_SERVER_FINISH                              239
@@ -2749,6 +2766,9 @@ void ERR_load_SSL_strings(void);
 # define SSL_F_SSL_CTX_SET_SESSION_ID_CONTEXT             219
 # define SSL_F_SSL_CTX_SET_SSL_VERSION                    170
 # define SSL_F_SSL_CTX_SET_TRUST                          229
+# define SSL_F_SSL_CTX_USE_ALTPRIVATEKEY                  343
+# define SSL_F_SSL_CTX_USE_ALTPRIVATEKEY_ASN1             344
+# define SSL_F_SSL_CTX_USE_ALTPRIVATEKEY_FILE             345
 # define SSL_F_SSL_CTX_USE_CERTIFICATE                    171
 # define SSL_F_SSL_CTX_USE_CERTIFICATE_ASN1               172
 # define SSL_F_SSL_CTX_USE_CERTIFICATE_CHAIN_FILE         220
@@ -2791,6 +2811,7 @@ void ERR_load_SSL_strings(void);
 # define SSL_F_SSL_SESSION_PRINT_FP                       190
 # define SSL_F_SSL_SESSION_SET1_ID_CONTEXT                312
 # define SSL_F_SSL_SESS_CERT_NEW                          225
+# define SSL_F_SSL_SET_ALT_PKEY                           346
 # define SSL_F_SSL_SET_CERT                               191
 # define SSL_F_SSL_SET_CIPHER_LIST                        271
 # define SSL_F_SSL_SET_FD                                 192
@@ -2857,8 +2878,8 @@ void ERR_load_SSL_strings(void);
 # define SSL_R_BAD_ECPOINT                                306
 # define SSL_R_BAD_HANDSHAKE_LENGTH                       332
 # define SSL_R_BAD_HELLO_REQUEST                          105
-# define SSL_R_BAD_LENGTH                                 271
 # define SSL_R_BAD_HSS_SIGNATURE                          500
+# define SSL_R_BAD_LENGTH                                 271
 # define SSL_R_BAD_MAC_DECODE                             113
 # define SSL_R_BAD_MAC_LENGTH                             333
 # define SSL_R_BAD_MESSAGE_TYPE                           114
@@ -3164,7 +3185,7 @@ void ERR_load_SSL_strings(void);
 # define SSL_R_X509_LIB                                   268
 # define SSL_R_X509_VERIFICATION_SETUP_PROBLEMS           269
 
-#ifdef  __cplusplus
+# ifdef  __cplusplus
 }
-#endif
+# endif
 #endif
diff --git a/ssl/ssl_cert.c b/ssl/ssl_cert.c
index e3f2f58..78892a9 100644
--- a/ssl/ssl_cert.c
+++ b/ssl/ssl_cert.c
@@ -115,6 +115,77 @@
  * ECC cipher suite support in OpenSSL originally developed by
  * SUN MICROSYSTEMS, INC., and contributed to the OpenSSL project.
  */
+/* ====================================================================
+ * Isara Corporation Quantum Safe EST Proprietary Software License
+ * Statement
+ *
+ * LICENSE AGREEMENT: The Product(s) that reference this license include
+ * embedded proprietary software and software “plug-ins” in source code or
+ * object code or both (the “Software”) and accompanying materials (the
+ * “Documentation”) that are subject to the license terms and restrictions
+ * described below (the “License"). If you do not agree to the License
+ * terms, do not use the Product, notify Isara Corporation (“Isara”) by
+ * electronic mail at sales@isara.com and erase any copies of the Product
+ * in your possession. If you are entering into this License on behalf of
+ * a company or other legal entity, you represent that you have the right
+ * to bind that entity to all terms, and “you” refers both to you
+ * personally and such entity.
+ *
+ * USE AND DISTRIBUTION: You may use the Software only in the form and in
+ * the Product(s) delivered to you for the purposes of integration,
+ * development and testing with your own products and/or as part of a
+ * monitoring and/or control group beta test with third parties that agree
+ * in writing to be bound by the terms of this License.
+ *
+ * ADDITIONAL RESTRICTIONS: You shall not use, modify, reproduce, reverse
+ * engineer, disassemble, decompile or otherwise attempt to derive source
+ * code from the Software (except to the extent that such limitations may
+ * not be prohibited by law), sublicense, or distribute the Software or
+ * Documentation other than as permitted by this License. You shall not
+ * remove any proprietary notices, labels or marks on the Product(s) “ZIP
+ * file”, Software or Documentation. No license is granted to use or
+ * reproduce any Isara trademarks.
+ *
+ * OWNERSHIP AND NOTICE: Except for the limited rights granted above,
+ * Isara and its suppliers retain all right, title and interest in and to
+ * the Software and Documentation, including copyrights, patents, trade
+ * secrets and other proprietary rights. Certain components of the
+ * Software that are subject to open source and third party licenses, the
+ * terms and conditions of which can found at https://github.com/cisco and
+ * select the applicable hash-sigs or libest license filed on the Github
+ * repository. If you require additional guidance, notify sales@isara.com
+ * for assistance. As a condition of the License, you agree to comply with
+ * all of the foregoing open source and third party license terms. Unless
+ * required by applicable law, such components are provided on an ‘AS IS’
+ * BASIS, WITHOUT EXPRESS OR IMPLIED WARRANTIES OR CONDITIONS OF ANY KIND.
+ *
+ * WARRANTY DISCLAIMER: THE SOFTWARE AND DOCUMENTATION ARE PROVIDED TO YOU
+ * "AS IS", AND YOU ASSUME THE ENTIRE RISK OF THEIR USE. ISARA AND ITS
+ * SUPPLIERS MAKES NO WARRANTIES OR CONDITIONS, EXPRESS, IMPLIED,
+ * STATUTORY OR IN ANY COMMUNICATION WITH YOU, AND ISARA CORPORATION
+ * EXPRESSLY DISCLAIMS ANY IMPLIED WARRANTIES OF MERCHANTABILITY, FITNESS
+ * FOR A PARTICULAR PURPOSE OR NONINFRINGEMENT WITH RESPECT TO THE
+ * SOFTWARE (INCLUDING ANY MODIFICATIONS MADE THERETO BY ANY PERSON
+ * WHETHER OR NOT AN EMPLOYEE OR CONTRACTOR OF ISARA) OR DOCUMENTATION
+ * PROVIDED TO YOU. ISARA EMPLOYEES AND OTHER PERSONNEL ARE NOT AUTHORIZED
+ * TO MAKE ANY WARRANTY THAT IS INCONSISTENT WITH THIS DISCLAIMER.
+ *
+ * LIMITATION OF LIABILITY: IN NO EVENT WILL ISARA OR ITS SUPPLIERS AND
+ * SUPPLIERS BE LIABLE FOR LOSS OF DATA, LOST PROFITS, COST OF COVER, OR
+ * OTHER SPECIAL, INCIDENTAL, PUNITIVE, CONSEQUENTIAL, OR INDIRECT DAMAGES
+ * ARISING FROM USE OF THE SOFTWARE OR DOCUMENTATION, HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, AND REGARDLESS OF WHETHER ISARA OR ITS
+ * SUPPLIERS HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  ISARA
+ * AND ITS SUPPLIERS BEAR NO LIABILITY FOR ANY PROGRAMS OR DATA STORED IN
+ * OR USED WITH THIS PRODUCT, INCLUDING THE COST OF RECOVERING SUCH
+ * PROGRAMS OR DATA.
+ *
+ * Copyright (c) 2017 ISARA Corporation. All Rights Reserved. This file
+ * contains Proprietary information of Isara Corporation. Unauthorized
+ * copying or use of this file via any medium is strictly prohibited.
+ * Written by Jerry Sui, jerry.sui@isara.com; Daniel Van Geest,
+ * daniel.vangeest@isara.com, December, 2017.
+ */
 
 #include <stdio.h>
 
@@ -128,12 +199,458 @@
 #include <openssl/bio.h>
 #include <openssl/pem.h>
 #include <openssl/x509v3.h>
+#include <openssl/asn1.h>
 #ifndef OPENSSL_NO_DH
 # include <openssl/dh.h>
 #endif
 #include <openssl/bn.h>
 #include "ssl_locl.h"
 
+
+static int iqrssl_cert_verify(X509_STORE_CTX *ctx)
+{
+    X509 *subject_cert = NULL;
+    X509 *issuer_cert = NULL;
+    X509 *alt_free_cert = NULL;
+
+    STACK_OF(X509) *cert_chain = NULL;
+    int cert_depth = 0;
+
+    int alt_pub_key_idx = -1;
+    int alt_sig_alg_ind = -1;
+    X509_ALGOR *alt_sig_alg = NULL;
+    X509_EXTENSION *alt_sig_alg_ext = NULL;
+
+    int alt_sig_val_idx = -1;
+    X509_EXTENSION *alt_sig_val_ext = NULL;
+    X509_EXTENSION *new_alt_sig_val_ext = NULL;
+    X509_ALGOR *algo_holder = NULL;
+
+    ASN1_BIT_STRING *alt_sig_val = NULL;
+
+    EVP_PKEY *pkey_cls_vfy = NULL;
+    EVP_PKEY *alt_pub_key = NULL;
+
+    int ok = 0;
+
+    subject_cert = X509_STORE_CTX_get_current_cert(ctx);
+    if (subject_cert == NULL) {
+        SSLerr(SSL_F_IQRSSL_CERT_VERIFY, ERR_R_X509_LIB);
+        goto end;
+    }
+
+    cert_chain = X509_STORE_CTX_get1_chain(ctx);
+    if (cert_chain == NULL) {
+        SSLerr(SSL_F_IQRSSL_CERT_VERIFY, ERR_R_X509_LIB);
+        goto end;
+    }
+
+    cert_depth = X509_STORE_CTX_get_error_depth(ctx);
+    if (sk_X509_num(cert_chain) - 1 == cert_depth) {
+        /* This is a root cert.
+         * If it is self-signed then skip verifying it.
+         * If it is not self-signed then we do not have the signer cert
+         * so we cannot verify it.
+         */
+
+        ok = 1;
+        goto end;
+    }
+
+    /* Grab the next cert in the stack, which should be the issuer cert. OpenSSL upper layer
+     * should have checked that for us so we do not need to bother with any checks.
+     */
+    issuer_cert = sk_X509_value(cert_chain, cert_depth + 1);
+    if (issuer_cert == NULL) {
+        SSLerr(SSL_F_IQRSSL_CERT_VERIFY, ERR_R_X509_LIB);
+        goto end;
+    }
+
+    /* If the caller does not want to verify alternative signature,
+     * then only classical (stock) signature is verified.
+     */
+    if (!(ctx->param->flags & X509_V_FLAG_ALT_SIG)) {
+        pkey_cls_vfy = X509_get_pubkey(issuer_cert);
+        if (pkey_cls_vfy == NULL) {
+            SSLerr(SSL_F_IQRSSL_CERT_VERIFY, ERR_R_X509_LIB);
+            goto end;
+        }
+
+        /* Perform cert verification. */
+        if (X509_verify(subject_cert, pkey_cls_vfy) <= 0) {
+            SSLerr(SSL_F_IQRSSL_CERT_VERIFY, ERR_R_X509_LIB);
+            goto end;
+        }
+
+        ok = 1;
+        goto end;
+    }
+
+    /* Find the issuer's ALT subject public key info extension. */
+    alt_pub_key_idx = X509_get_ext_by_NID(issuer_cert, NID_subj_alt_pub_key, -1);
+
+    /* Find the subject's ALT signature extension. */
+    alt_sig_val_idx = X509_get_ext_by_NID(subject_cert, NID_alt_sigval, -1);
+
+    if ((alt_pub_key_idx < 0 && alt_sig_val_idx < 0) ||
+        (alt_pub_key_idx >= 0 && alt_sig_val_idx < 0)) {
+        /* Case 1: Both the issuer cert and the subject cert are classical.
+         * The following verifies the subject cert classically (not necessarily with
+         * classical sig algorithms, because classical cert can still be created
+         * with ALT sig algorithms).
+         *
+         * Case 2: The issuer cert is QS but the subject cert is classical.
+         * This also falls into classical verification.
+         */
+
+        pkey_cls_vfy = X509_get_pubkey(issuer_cert);
+        if (pkey_cls_vfy == NULL) {
+            SSLerr(SSL_F_IQRSSL_CERT_VERIFY, ERR_R_X509_LIB);
+            goto end;
+        }
+
+        /* Perform cert verification. */
+        if (X509_verify(subject_cert, pkey_cls_vfy) <= 0) {
+            SSLerr(SSL_F_IQRSSL_CERT_VERIFY, ERR_R_X509_LIB);
+            goto end;
+        }
+    } else if (alt_pub_key_idx < 0 && alt_sig_val_idx >= 0) {
+        /* Cannot find issuer's ALT subject public key info extension,
+         * but the subject cert contains ALT signature extension.
+         * This should not happen, as the classical issuer cannot produce a
+         * QS cert. Therefore, something is wrong, e.g., the issuer/subject
+         * cert is incorrect).
+         */
+
+        SSLerr(SSL_F_IQRSSL_CERT_VERIFY, ERR_R_X509_LIB);
+        goto end;
+    } else if (alt_pub_key_idx >= 0 && alt_sig_val_idx >= 0) {
+        /* Both the issuer cert and the subject cert are QS.
+         * Verify the subject cert using ALT sig algorithm.
+         */
+
+        /* Get the issuer's ALT public key. */
+        alt_pub_key = SSL_get_alt_pubkey(issuer_cert);
+
+        if (alt_pub_key == NULL) {
+            SSLerr(SSL_F_IQRSSL_CERT_VERIFY, ERR_R_X509_LIB);
+            goto end;
+        }
+
+        /* Find the subject's ALT signature algorithm extension. */
+        alt_sig_alg_ind = X509_get_ext_by_NID(subject_cert, NID_alt_sigalg, -1);
+        if (alt_sig_alg_ind < 0) {
+            SSLerr(SSL_F_IQRSSL_CERT_VERIFY, ERR_R_X509_LIB);
+            goto end;
+        }
+
+        /* Get the subject's ALT signature algorithm extension. */
+        alt_sig_alg_ext = X509_get_ext(subject_cert, alt_sig_alg_ind);
+        if (alt_sig_alg_ext == NULL) {
+            SSLerr(SSL_F_IQRSSL_CERT_VERIFY, ERR_R_X509_LIB);
+            goto end;
+        }
+
+        /* Convert the subject's ALT signature algorithm extension into internal representation. */
+        alt_sig_alg = X509V3_EXT_d2i(alt_sig_alg_ext);
+        if (alt_sig_alg == NULL) {
+            SSLerr(SSL_F_IQRSSL_CERT_VERIFY, ERR_R_X509_LIB);
+            goto end;
+        }
+
+        /* Get the subject's ALT signature extension. */
+        alt_sig_val_ext = X509_get_ext(subject_cert, alt_sig_val_idx);
+        if (alt_sig_val_ext == NULL) {
+            SSLerr(SSL_F_IQRSSL_CERT_VERIFY, ERR_R_X509_LIB);
+            goto end;
+        }
+
+        /* Converting the subject's ALT signature extension into internal representation. */
+        alt_sig_val = X509V3_EXT_d2i(alt_sig_val_ext);
+        if (alt_sig_val == NULL) {
+            SSLerr(SSL_F_IQRSSL_CERT_VERIFY, ERR_R_X509_LIB);
+            goto end;
+        }
+
+        /* Duplicate the subject certificate, remove the ALT signature extension, and verify against that. */
+        alt_free_cert = X509_dup(subject_cert);
+        if (alt_free_cert == NULL) {
+            SSLerr(SSL_F_IQRSSL_CERT_VERIFY, ERR_R_X509_LIB);
+            goto end;
+        }
+
+        new_alt_sig_val_ext = X509_get_ext(alt_free_cert, alt_sig_val_idx);
+        if (new_alt_sig_val_ext == NULL) {
+            SSLerr(SSL_F_IQRSSL_CERT_VERIFY, ERR_R_X509_LIB);
+            goto end;
+        }
+
+        if (X509_delete_ext(alt_free_cert, alt_sig_val_idx) == NULL) {
+            SSLerr(SSL_F_IQRSSL_CERT_VERIFY, ERR_R_X509_LIB);
+            goto end;
+        }
+
+        /* The classical algorithm identifier is not part of the QS signature. */
+        algo_holder = alt_free_cert->cert_info->signature;
+        alt_free_cert->cert_info->signature = NULL;
+
+        /* Stuff is being cached. (https://www.openssl.org/docs/man1.1.0/crypto/X509_sign.html.) */
+        alt_free_cert->cert_info->enc.modified = 1;
+
+        /* Perform cert verification. */
+        if (ASN1_item_verify(ASN1_ITEM_rptr(X509_CINF), alt_sig_alg, alt_sig_val, alt_free_cert->cert_info, alt_pub_key) <= 0) {
+            SSLerr(SSL_F_IQRSSL_CERT_VERIFY, ERR_R_X509_LIB);
+            goto end;
+        }
+    }
+
+    ok = 1;
+
+end:
+    if (cert_chain) {
+        sk_X509_pop_free(cert_chain, X509_free);
+    }
+
+    if (pkey_cls_vfy) {
+        EVP_PKEY_free(pkey_cls_vfy);
+    }
+
+    if (alt_pub_key) {
+        EVP_PKEY_free(alt_pub_key);
+    }
+
+    if (alt_sig_alg) {
+        X509_ALGOR_free(alt_sig_alg);
+    }
+
+    if (alt_sig_val) {
+        ASN1_BIT_STRING_free(alt_sig_val);
+    }
+
+    if (alt_free_cert) {
+        X509_free(alt_free_cert);
+    }
+
+    if (new_alt_sig_val_ext) {
+        X509_EXTENSION_free(new_alt_sig_val_ext);
+    }
+
+    if (algo_holder) {
+        X509_ALGOR_free(algo_holder);
+    }
+
+    return ok;
+}
+
+static int iqrssl_check_cert_time(X509_STORE_CTX *ctx, X509 *x)
+{
+    time_t *ptime = 0;
+    int i = 0;
+
+    if (ctx->param->flags & X509_V_FLAG_USE_CHECK_TIME) {
+        ptime = &ctx->param->check_time;
+    } else {
+        ptime = NULL;
+    }
+
+    /* Check not-before time. */
+    i = X509_cmp_time(X509_get_notBefore(x), ptime);
+    if (i == 0) {
+        ctx->error = X509_V_ERR_ERROR_IN_CERT_NOT_BEFORE_FIELD;
+        ctx->current_cert = x;
+        if (!ctx->verify_cb(0, ctx)) {
+            return 0;
+        }
+    }
+
+    if (i > 0) {
+        ctx->error = X509_V_ERR_CERT_NOT_YET_VALID;
+        ctx->current_cert = x;
+        if (!ctx->verify_cb(0, ctx)) {
+            return 0;
+        }
+    }
+
+    /* Check not-after time. */
+    i = X509_cmp_time(X509_get_notAfter(x), ptime);
+    if (i == 0) {
+        ctx->error = X509_V_ERR_ERROR_IN_CERT_NOT_AFTER_FIELD;
+        ctx->current_cert = x;
+        if (!ctx->verify_cb(0, ctx)) {
+            return 0;
+        }
+    }
+
+    if (i < 0) {
+        ctx->error = X509_V_ERR_CERT_HAS_EXPIRED;
+        ctx->current_cert = x;
+        if (!ctx->verify_cb(0, ctx)) {
+            return 0;
+        }
+    }
+
+    return 1;
+}
+
+static int iqrssl_cert_chain_verify_cb(X509_STORE_CTX *ctx)
+{
+    int ok = 0;
+    int n = 0;
+    X509 *subject_cert = NULL;
+    X509 *issuer_cert = NULL;
+    int (*cb) (int xok, X509_STORE_CTX *xctx);
+
+    if (ctx == NULL) {
+        goto end;
+    }
+
+    /* Set the error callback. */
+    cb = ctx->verify_cb;
+
+    /* Get the number of certs in the chain. */
+    n = sk_X509_num(ctx->chain);
+    if (n <= 0) {
+        ctx->error = X509_V_ERR_UNSPECIFIED;
+        SSLerr(SSL_F_IQRSSL_CERT_CHAIN_VERIFY_CB, ERR_R_X509_LIB);
+
+        ok = cb(0, ctx);
+        goto end;
+    }
+
+    /* Get the last cert in the chain, mostly likely a self-signed cert. */
+    n--;
+    ctx->error_depth = n;
+    issuer_cert = sk_X509_value(ctx->chain, n);
+    if (issuer_cert == NULL) {
+        ctx->error = X509_V_ERR_UNABLE_TO_GET_ISSUER_CERT;
+        SSLerr(SSL_F_IQRSSL_CERT_CHAIN_VERIFY_CB, ERR_R_X509_LIB);
+
+        ok = cb(0, ctx);
+        goto end;
+    }
+
+    /* Check if the issuer of subject cert is the subject of the issuer cert. */
+    if (ctx->check_issued(ctx, issuer_cert, issuer_cert)) {
+        /* Self-signed cert */
+        subject_cert = issuer_cert;
+    } else {
+        /* Not a self-signed cert */
+        if (ctx->param->flags & X509_V_FLAG_PARTIAL_CHAIN) {
+            subject_cert = issuer_cert;
+            goto check_cert;
+        }
+
+        if (n <= 0) {
+            ctx->error = X509_V_ERR_UNABLE_TO_VERIFY_LEAF_SIGNATURE;
+            ctx->current_cert = issuer_cert;
+            SSLerr(SSL_F_IQRSSL_CERT_CHAIN_VERIFY_CB, ERR_R_X509_LIB);
+
+            ok = cb(0, ctx);
+            goto end;
+        } else {
+            /* Get the next cert in the chain, which should be the subject cert.*/
+            n--;
+            ctx->error_depth = n;
+            subject_cert = sk_X509_value(ctx->chain, n);
+            if (subject_cert == NULL) {
+                ctx->error = X509_V_ERR_UNSPECIFIED;
+                ctx->current_cert = issuer_cert;
+                SSLerr(SSL_F_IQRSSL_CERT_CHAIN_VERIFY_CB, ERR_R_X509_LIB);
+
+                ok = cb(0, ctx);
+                goto end;
+            }
+
+            if (!ctx->check_issued(ctx, subject_cert, issuer_cert)) {
+                ctx->error = X509_V_ERR_SUBJECT_ISSUER_MISMATCH;
+                ctx->current_issuer = issuer_cert;
+                ctx->current_cert = subject_cert;
+                SSLerr(SSL_F_IQRSSL_CERT_CHAIN_VERIFY_CB, ERR_R_X509_LIB);
+
+                ok = cb(0, ctx);
+                goto end;
+            }
+        }
+    }
+
+    while (n >= 0) {
+        ctx->error_depth = n;
+
+        /*
+         * Perform cert verification.
+         *
+         * Skip signature check for self signed certificates unless
+         * explicitly asked for. This is the default behavior of openssl.
+         */
+        if (!subject_cert->valid && (subject_cert != issuer_cert || (ctx->param->flags & X509_V_FLAG_CHECK_SS_SIGNATURE))) {
+            ctx->current_issuer = issuer_cert;
+            ctx->current_cert = subject_cert;
+
+            ok = iqrssl_cert_verify(ctx);
+            if (!ok) {
+                ctx->error = X509_V_ERR_CERT_SIGNATURE_FAILURE;
+                SSLerr(SSL_F_IQRSSL_CERT_CHAIN_VERIFY_CB, ERR_R_X509_LIB);
+
+                ok = cb(0, ctx);
+                goto end;
+            }
+        }
+
+        subject_cert->valid = 1;
+
+check_cert:
+        /* Check cert validity. */
+        ok = iqrssl_check_cert_time(ctx, subject_cert);
+        if (!ok) {
+            SSLerr(SSL_F_IQRSSL_CERT_CHAIN_VERIFY_CB, ERR_R_X509_LIB);
+
+            ok = cb(0, ctx);
+            goto end;
+        }
+
+        /*
+         * Call the error callback with 1 (success).
+         * This gives the user a chance to do things like printing the status, etc.
+         */
+        ctx->current_issuer = issuer_cert;
+        ctx->current_cert = subject_cert;
+
+        ok = (*cb) (1, ctx);
+        if (!ok) {
+            SSLerr(SSL_F_IQRSSL_CERT_CHAIN_VERIFY_CB, ERR_R_X509_LIB);
+            goto end;
+        }
+
+        /* Go down one level in the cert-chain and do the verification again. */
+        n--;
+        if (n >= 0) {
+            issuer_cert = subject_cert;
+            subject_cert = sk_X509_value(ctx->chain, n);
+            if (subject_cert == NULL) {
+                ctx->error = X509_V_ERR_UNSPECIFIED;
+                SSLerr(SSL_F_IQRSSL_CERT_CHAIN_VERIFY_CB, ERR_R_X509_LIB);
+
+                ok = cb(0, ctx);
+                goto end;
+            }
+
+            if (!ctx->check_issued(ctx, subject_cert, issuer_cert)) {
+                ctx->error = X509_V_ERR_SUBJECT_ISSUER_MISMATCH;
+                ctx->current_issuer = issuer_cert;
+                ctx->current_cert = subject_cert;
+                SSLerr(SSL_F_IQRSSL_CERT_CHAIN_VERIFY_CB, ERR_R_X509_LIB);
+
+                ok = cb(0, ctx);
+                goto end;
+            }
+        }
+    }
+
+    ok = 1;
+end:
+    return ok;
+}
+
 int SSL_get_ex_data_X509_STORE_CTX_idx(void)
 {
     static volatile int ssl_x509_store_ctx_idx = -1;
@@ -311,6 +828,8 @@ CERT *ssl_cert_dup(CERT *cert)
             }
         }
         rpk->valid_flags = 0;
+        rpk->is_mpka_cert = cpk->is_mpka_cert;
+        rpk->is_mpka_key = cpk->is_mpka_key;
 #ifndef OPENSSL_NO_TLSEXT
         if (cert->pkeys[i].serverinfo != NULL) {
             /* Just copy everything. */
@@ -450,6 +969,8 @@ void ssl_cert_clear_certs(CERT *c)
 #endif
         /* Clear all flags apart from explicit sign */
         cpk->valid_flags &= CERT_PKEY_EXPLICIT_SIGN;
+        cpk->is_mpka_cert = 0;
+        cpk->is_mpka_key = 0;
     }
 }
 
@@ -539,12 +1060,43 @@ int ssl_cert_inst(CERT **o)
 
 int ssl_cert_set0_chain(CERT *c, STACK_OF(X509) *chain)
 {
+    int i = 0;
+    int alt_pub_key_idx = -1;
+    EVP_PKEY *alt_pub_key = NULL;
     CERT_PKEY *cpk = c->key;
     if (!cpk)
         return 0;
     if (cpk->chain)
         sk_X509_pop_free(cpk->chain, X509_free);
     cpk->chain = chain;
+
+    /*
+     * Cert chain also needs to be set for the alt public key,
+     * so that alt cert verification can find the proper issuer.
+     */
+    alt_pub_key_idx = X509_get_ext_by_NID(cpk->x509, NID_subj_alt_pub_key, -1);
+    if (alt_pub_key_idx >= 0) {
+        /* Get the hybrid ALT PKEY. */
+        alt_pub_key = SSL_get_alt_pubkey(cpk->x509);
+        if (alt_pub_key == NULL) {
+            return 0;
+        }
+
+        i = ssl_cert_type(cpk->x509, alt_pub_key);
+        if (i < 0) {
+            EVP_PKEY_free(alt_pub_key);
+            return 0;
+        }
+
+        EVP_PKEY_free(alt_pub_key);
+
+        if (c->pkeys[i].chain) {
+            sk_X509_pop_free(c->pkeys[i].chain, X509_free);
+        }
+
+        c->pkeys[i].chain = chain;
+    }
+
     return 1;
 }
 
@@ -565,6 +1117,9 @@ int ssl_cert_set1_chain(CERT *c, STACK_OF(X509) *chain)
 
 int ssl_cert_add0_chain_cert(CERT *c, X509 *x)
 {
+    int i = 0;
+    int alt_pub_key_idx = -1;
+    EVP_PKEY *alt_pub_key = NULL;
     CERT_PKEY *cpk = c->key;
     if (!cpk)
         return 0;
@@ -572,6 +1127,39 @@ int ssl_cert_add0_chain_cert(CERT *c, X509 *x)
         cpk->chain = sk_X509_new_null();
     if (!cpk->chain || !sk_X509_push(cpk->chain, x))
         return 0;
+
+    /*
+     * Cert chain also needs to be increased for the alt public key,
+     * so that alt cert verification can find the proper issuer.
+     */
+    alt_pub_key_idx = X509_get_ext_by_NID(cpk->x509, NID_subj_alt_pub_key, -1);
+    if (alt_pub_key_idx >= 0) {
+        /* Get the hybrid ALT PKEY. */
+        alt_pub_key = SSL_get_alt_pubkey(cpk->x509);
+        if (alt_pub_key == NULL) {
+            return 0;
+        }
+
+        i = ssl_cert_type(cpk->x509, alt_pub_key);
+        if (i < 0) {
+            EVP_PKEY_free(alt_pub_key);
+            return 0;
+        }
+
+        EVP_PKEY_free(alt_pub_key);
+
+        if (c->pkeys[i].chain == NULL) {
+            c->pkeys[i].chain = sk_X509_new_null();
+        }
+
+        if (c->pkeys[i].chain == NULL || !sk_X509_push(c->pkeys[i].chain, x)) {
+            return 0;
+        }
+
+        // Need to increase the reference for this cert.
+        CRYPTO_add(&x->references, 1, CRYPTO_LOCK_X509);
+    }
+
     return 1;
 }
 
@@ -724,6 +1312,10 @@ int ssl_verify_cert_chain(SSL *s, STACK_OF(X509) *sk)
     if ((sk == NULL) || (sk_X509_num(sk) == 0))
         return (0);
 
+    if (verify_store && (verify_store->verify == NULL)) {
+        X509_STORE_set_verify_func(verify_store, iqrssl_cert_chain_verify_cb);
+    }
+
     x = sk_X509_value(sk, 0);
     if (!X509_STORE_CTX_init(&ctx, verify_store, x, sk)) {
         SSLerr(SSL_F_SSL_VERIFY_CERT_CHAIN, ERR_R_X509_LIB);
@@ -752,6 +1344,22 @@ int ssl_verify_cert_chain(SSL *s, STACK_OF(X509) *sk)
     if (s->verify_callback)
         X509_STORE_CTX_set_verify_cb(&ctx, s->verify_callback);
 
+    if (!(s->s3->tmp.new_cipher->algorithm_auth & SSL_aHSS)) {
+        /* Do not set X509_V_FLAG_ALT_SIG, which means that verification
+         * of the cert chain will be done with classical (stock) signature, even
+         * when certs in the chain may contain alternative signatures (QS signatures).
+         *
+         * This is done in situations such as when the ciphersuite used contains only
+         * classical auth and not QS auth.
+         */
+    } else {
+        /* Verify the cert chain using alternative signatures.
+         * If a cert in the chain does not contain alternative signature,
+         * then verification will fall back to stock signature just for that cert.
+         */
+        X509_STORE_CTX_set_flags(&ctx, X509_V_FLAG_ALT_SIG);
+    }
+
     if (s->ctx->app_verify_callback != NULL)
 #if 1                           /* new with OpenSSL 0.9.7 */
         i = s->ctx->app_verify_callback(&ctx, s->ctx->app_verify_arg);
diff --git a/ssl/ssl_err.c b/ssl/ssl_err.c
index a4c17a6..a02a466 100644
--- a/ssl/ssl_err.c
+++ b/ssl/ssl_err.c
@@ -1,6 +1,6 @@
 /* ssl/ssl_err.c */
 /* ====================================================================
- * Copyright (c) 1999-2016 The OpenSSL Project.  All rights reserved.
+ * Copyright (c) 1999-2018 The OpenSSL Project.  All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
  * modification, are permitted provided that the following conditions
@@ -84,6 +84,7 @@ static ERR_STRING_DATA SSL_str_functs[] = {
     {ERR_FUNC(SSL_F_DTLS1_CHECK_TIMEOUT_NUM), "dtls1_check_timeout_num"},
     {ERR_FUNC(SSL_F_DTLS1_CLIENT_HELLO), "dtls1_client_hello"},
     {ERR_FUNC(SSL_F_DTLS1_CONNECT), "dtls1_connect"},
+    {ERR_FUNC(SSL_F_DTLS1_ENC), "DTLS1_ENC"},
     {ERR_FUNC(SSL_F_DTLS1_GET_HELLO_VERIFY), "DTLS1_GET_HELLO_VERIFY"},
     {ERR_FUNC(SSL_F_DTLS1_GET_MESSAGE), "dtls1_get_message"},
     {ERR_FUNC(SSL_F_DTLS1_GET_MESSAGE_FRAGMENT),
@@ -124,6 +125,9 @@ static ERR_STRING_DATA SSL_str_functs[] = {
     {ERR_FUNC(SSL_F_GET_SERVER_STATIC_DH_KEY), "GET_SERVER_STATIC_DH_KEY"},
     {ERR_FUNC(SSL_F_GET_SERVER_VERIFY), "GET_SERVER_VERIFY"},
     {ERR_FUNC(SSL_F_I2D_SSL_SESSION), "i2d_SSL_SESSION"},
+    {ERR_FUNC(SSL_F_IQRSSL_CERT_CHAIN_VERIFY_CB),
+     "IQRSSL_CERT_CHAIN_VERIFY_CB"},
+    {ERR_FUNC(SSL_F_IQRSSL_CERT_VERIFY), "IQRSSL_CERT_VERIFY"},
     {ERR_FUNC(SSL_F_READ_N), "READ_N"},
     {ERR_FUNC(SSL_F_REQUEST_CERTIFICATE), "REQUEST_CERTIFICATE"},
     {ERR_FUNC(SSL_F_SERVER_FINISH), "SERVER_FINISH"},
@@ -260,6 +264,11 @@ static ERR_STRING_DATA SSL_str_functs[] = {
      "SSL_CTX_set_session_id_context"},
     {ERR_FUNC(SSL_F_SSL_CTX_SET_SSL_VERSION), "SSL_CTX_set_ssl_version"},
     {ERR_FUNC(SSL_F_SSL_CTX_SET_TRUST), "SSL_CTX_set_trust"},
+    {ERR_FUNC(SSL_F_SSL_CTX_USE_ALTPRIVATEKEY), "SSL_CTX_use_ALTPrivateKey"},
+    {ERR_FUNC(SSL_F_SSL_CTX_USE_ALTPRIVATEKEY_ASN1),
+     "SSL_CTX_use_ALTPrivateKey_ASN1"},
+    {ERR_FUNC(SSL_F_SSL_CTX_USE_ALTPRIVATEKEY_FILE),
+     "SSL_CTX_use_ALTPrivateKey_file"},
     {ERR_FUNC(SSL_F_SSL_CTX_USE_CERTIFICATE), "SSL_CTX_use_certificate"},
     {ERR_FUNC(SSL_F_SSL_CTX_USE_CERTIFICATE_ASN1),
      "SSL_CTX_use_certificate_ASN1"},
@@ -322,6 +331,7 @@ static ERR_STRING_DATA SSL_str_functs[] = {
     {ERR_FUNC(SSL_F_SSL_SESSION_SET1_ID_CONTEXT),
      "SSL_SESSION_set1_id_context"},
     {ERR_FUNC(SSL_F_SSL_SESS_CERT_NEW), "ssl_sess_cert_new"},
+    {ERR_FUNC(SSL_F_SSL_SET_ALT_PKEY), "SSL_SET_ALT_PKEY"},
     {ERR_FUNC(SSL_F_SSL_SET_CERT), "SSL_SET_CERT"},
     {ERR_FUNC(SSL_F_SSL_SET_CIPHER_LIST), "SSL_set_cipher_list"},
     {ERR_FUNC(SSL_F_SSL_SET_FD), "SSL_set_fd"},
@@ -402,6 +412,7 @@ static ERR_STRING_DATA SSL_str_reasons[] = {
     {ERR_REASON(SSL_R_BAD_ECPOINT), "bad ecpoint"},
     {ERR_REASON(SSL_R_BAD_HANDSHAKE_LENGTH), "bad handshake length"},
     {ERR_REASON(SSL_R_BAD_HELLO_REQUEST), "bad hello request"},
+    {ERR_REASON(SSL_R_BAD_HSS_SIGNATURE), "bad hss signature"},
     {ERR_REASON(SSL_R_BAD_LENGTH), "bad length"},
     {ERR_REASON(SSL_R_BAD_MAC_DECODE), "bad mac decode"},
     {ERR_REASON(SSL_R_BAD_MAC_LENGTH), "bad mac length"},
@@ -546,6 +557,7 @@ static ERR_STRING_DATA SSL_str_reasons[] = {
      "missing export tmp dh key"},
     {ERR_REASON(SSL_R_MISSING_EXPORT_TMP_RSA_KEY),
      "missing export tmp rsa key"},
+    {ERR_REASON(SSL_R_MISSING_HSS_SIGNING_CERT), "missing hss signing cert"},
     {ERR_REASON(SSL_R_MISSING_RSA_CERTIFICATE), "missing rsa certificate"},
     {ERR_REASON(SSL_R_MISSING_RSA_ENCRYPTING_CERT),
      "missing rsa encrypting cert"},
@@ -753,11 +765,11 @@ static ERR_STRING_DATA SSL_str_reasons[] = {
      "tls illegal exporter label"},
     {ERR_REASON(SSL_R_TLS_INVALID_ECPOINTFORMAT_LIST),
      "tls invalid ecpointformat list"},
-    {ERR_REASON(SSL_R_TOO_MANY_WARN_ALERTS), "too many warn alerts"},
     {ERR_REASON(SSL_R_TLS_PEER_DID_NOT_RESPOND_WITH_CERTIFICATE_LIST),
      "tls peer did not respond with certificate list"},
     {ERR_REASON(SSL_R_TLS_RSA_ENCRYPTED_VALUE_LENGTH_IS_WRONG),
      "tls rsa encrypted value length is wrong"},
+    {ERR_REASON(SSL_R_TOO_MANY_WARN_ALERTS), "too many warn alerts"},
     {ERR_REASON(SSL_R_TRIED_TO_USE_UNSUPPORTED_CIPHER),
      "tried to use unsupported cipher"},
     {ERR_REASON(SSL_R_UNABLE_TO_DECODE_DH_CERTS),
diff --git a/ssl/ssl_lib.c b/ssl/ssl_lib.c
index 6342b77..319c5a7 100644
--- a/ssl/ssl_lib.c
+++ b/ssl/ssl_lib.c
@@ -141,6 +141,77 @@
  * OTHER ENTITY BASED ON INFRINGEMENT OF INTELLECTUAL PROPERTY RIGHTS OR
  * OTHERWISE.
  */
+/* ====================================================================
+ * Isara Corporation Quantum Safe EST Proprietary Software License
+ * Statement
+ *
+ * LICENSE AGREEMENT: The Product(s) that reference this license include
+ * embedded proprietary software and software “plug-ins” in source code or
+ * object code or both (the “Software”) and accompanying materials (the
+ * “Documentation”) that are subject to the license terms and restrictions
+ * described below (the “License"). If you do not agree to the License
+ * terms, do not use the Product, notify Isara Corporation (“Isara”) by
+ * electronic mail at sales@isara.com and erase any copies of the Product
+ * in your possession. If you are entering into this License on behalf of
+ * a company or other legal entity, you represent that you have the right
+ * to bind that entity to all terms, and “you” refers both to you
+ * personally and such entity.
+ *
+ * USE AND DISTRIBUTION: You may use the Software only in the form and in
+ * the Product(s) delivered to you for the purposes of integration,
+ * development and testing with your own products and/or as part of a
+ * monitoring and/or control group beta test with third parties that agree
+ * in writing to be bound by the terms of this License.
+ *
+ * ADDITIONAL RESTRICTIONS: You shall not use, modify, reproduce, reverse
+ * engineer, disassemble, decompile or otherwise attempt to derive source
+ * code from the Software (except to the extent that such limitations may
+ * not be prohibited by law), sublicense, or distribute the Software or
+ * Documentation other than as permitted by this License. You shall not
+ * remove any proprietary notices, labels or marks on the Product(s) “ZIP
+ * file”, Software or Documentation. No license is granted to use or
+ * reproduce any Isara trademarks.
+ *
+ * OWNERSHIP AND NOTICE: Except for the limited rights granted above,
+ * Isara and its suppliers retain all right, title and interest in and to
+ * the Software and Documentation, including copyrights, patents, trade
+ * secrets and other proprietary rights. Certain components of the
+ * Software that are subject to open source and third party licenses, the
+ * terms and conditions of which can found at https://github.com/cisco and
+ * select the applicable hash-sigs or libest license filed on the Github
+ * repository. If you require additional guidance, notify sales@isara.com
+ * for assistance. As a condition of the License, you agree to comply with
+ * all of the foregoing open source and third party license terms. Unless
+ * required by applicable law, such components are provided on an ‘AS IS’
+ * BASIS, WITHOUT EXPRESS OR IMPLIED WARRANTIES OR CONDITIONS OF ANY KIND.
+ *
+ * WARRANTY DISCLAIMER: THE SOFTWARE AND DOCUMENTATION ARE PROVIDED TO YOU
+ * "AS IS", AND YOU ASSUME THE ENTIRE RISK OF THEIR USE. ISARA AND ITS
+ * SUPPLIERS MAKES NO WARRANTIES OR CONDITIONS, EXPRESS, IMPLIED,
+ * STATUTORY OR IN ANY COMMUNICATION WITH YOU, AND ISARA CORPORATION
+ * EXPRESSLY DISCLAIMS ANY IMPLIED WARRANTIES OF MERCHANTABILITY, FITNESS
+ * FOR A PARTICULAR PURPOSE OR NONINFRINGEMENT WITH RESPECT TO THE
+ * SOFTWARE (INCLUDING ANY MODIFICATIONS MADE THERETO BY ANY PERSON
+ * WHETHER OR NOT AN EMPLOYEE OR CONTRACTOR OF ISARA) OR DOCUMENTATION
+ * PROVIDED TO YOU. ISARA EMPLOYEES AND OTHER PERSONNEL ARE NOT AUTHORIZED
+ * TO MAKE ANY WARRANTY THAT IS INCONSISTENT WITH THIS DISCLAIMER.
+ *
+ * LIMITATION OF LIABILITY: IN NO EVENT WILL ISARA OR ITS SUPPLIERS AND
+ * SUPPLIERS BE LIABLE FOR LOSS OF DATA, LOST PROFITS, COST OF COVER, OR
+ * OTHER SPECIAL, INCIDENTAL, PUNITIVE, CONSEQUENTIAL, OR INDIRECT DAMAGES
+ * ARISING FROM USE OF THE SOFTWARE OR DOCUMENTATION, HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, AND REGARDLESS OF WHETHER ISARA OR ITS
+ * SUPPLIERS HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  ISARA
+ * AND ITS SUPPLIERS BEAR NO LIABILITY FOR ANY PROGRAMS OR DATA STORED IN
+ * OR USED WITH THIS PRODUCT, INCLUDING THE COST OF RECOVERING SUCH
+ * PROGRAMS OR DATA.
+ *
+ * Copyright (c) 2017 ISARA Corporation. All Rights Reserved. This file
+ * contains Proprietary information of Isara Corporation. Unauthorized
+ * copying or use of this file via any medium is strictly prohibited.
+ * Written by Jerry Sui, jerry.sui@isara.com; Daniel Van Geest,
+ * daniel.vangeest@isara.com, December, 2017.
+ */
 
 #ifdef REF_CHECK
 # include <assert.h>
@@ -2326,7 +2397,19 @@ void ssl_set_cert_masks(CERT *c, const SSL_CIPHER *cipher)
 
     cpk = &(c->pkeys[SSL_PKEY_HSS]);
     if (cpk->x509 != NULL && cpk->privatekey != NULL) {
-        mask_a |= SSL_aHSS;
+        /* If the private key is a alternative key but the peer does not support MPKAC,
+         * then do not set the mask.
+         *
+         * I.e., only set this mask if the private key is not a alternative key, or if
+         * it is a alternative key and the peer supports MPKAC.
+         *
+         * This is done so that when the server chooses the ciphersuite, it would not
+         * accidentally choose one with auth corresponding to the alternative key while
+         * the client does not actually support MPKAC.
+         */
+        if ((cpk->is_mpka_key == 1 && c->peer_mpkac_support == 1) || cpk->is_mpka_key == 0) {
+            mask_a |= SSL_aHSS;
+        }
     }
 
     if (rsa_enc || (rsa_tmp && rsa_sign))
@@ -3043,6 +3126,68 @@ EVP_PKEY *SSL_get_privatekey(const SSL *s)
         return (NULL);
 }
 
+EVP_PKEY *SSL_get_alt_pubkey(X509 *x)
+{
+    int alt_pub_key_idx = -1;
+    X509_EXTENSION *alt_pub_key_ext = NULL;
+
+    X509_PUBKEY *alt_x509_pubkey = NULL;
+    SUBJECT_ALT_PUBLIC_KEY_INFO *alt_spki = NULL;
+
+    EVP_PKEY *alt_pub_key = NULL;
+
+    if (x == NULL) {
+        return NULL;
+    }
+
+    alt_pub_key_idx = X509_get_ext_by_NID(x, NID_subj_alt_pub_key, -1);
+    if (alt_pub_key_idx < 0 ) {
+        return NULL;
+    }
+
+    alt_pub_key_ext = X509_get_ext(x, alt_pub_key_idx);
+    if (alt_pub_key_ext == NULL) {
+        return NULL;
+    }
+
+    /* ASN.1 parse the ALT public key extension. */
+    alt_spki = X509V3_EXT_d2i(alt_pub_key_ext);
+    if (alt_spki == NULL) {
+        return NULL;
+    }
+
+    /* Convert the x509 formatted public key into an x509_PUBKEY. */
+    alt_x509_pubkey = X509_PUBKEY_new();
+    if (alt_x509_pubkey == NULL) {
+        SUBJECT_ALT_PUBLIC_KEY_INFO_free(alt_spki);
+        return NULL;
+    }
+
+    X509_ALGOR_free(alt_x509_pubkey->algor);
+    ASN1_BIT_STRING_free(alt_x509_pubkey->public_key);
+
+    alt_x509_pubkey->algor = alt_spki->algor;
+    alt_x509_pubkey->public_key = alt_spki->public_key;
+    alt_x509_pubkey->pkey = NULL;
+
+    /* Get the PKEY. */
+    alt_pub_key = X509_PUBKEY_get(alt_x509_pubkey);
+
+    alt_x509_pubkey->algor = NULL;
+    alt_x509_pubkey->public_key = NULL;
+    X509_PUBKEY_free(alt_x509_pubkey);
+    alt_x509_pubkey = NULL;
+
+    if (alt_pub_key == NULL) {
+        SUBJECT_ALT_PUBLIC_KEY_INFO_free(alt_spki);
+        return NULL;
+    }
+
+    SUBJECT_ALT_PUBLIC_KEY_INFO_free(alt_spki);
+
+    return alt_pub_key;
+}
+
 X509 *SSL_CTX_get0_certificate(const SSL_CTX *ctx)
 {
     if (ctx->cert != NULL)
diff --git a/ssl/ssl_locl.h b/ssl/ssl_locl.h
index e6d25ac..6cb3406 100644
--- a/ssl/ssl_locl.h
+++ b/ssl/ssl_locl.h
@@ -560,6 +560,18 @@ typedef struct cert_pkey_st {
      * at all.
      */
     int valid_flags;
+    /*
+     * Set if the referenced cert is an MPKA cert.
+     */
+    unsigned char is_mpka_cert;
+    /*
+     * Set if the private key is the alternative key for a MPKA cert.
+     *
+     * Note that referenced cert being an MPKAC does not necessarily mean
+     * the private key needs to be a alternative key, e.g., pkey loaded for
+     * the non-alternative part of the cert.
+     */
+    unsigned char is_mpka_key;
 } CERT_PKEY;
 /* Retrieve Suite B flags */
 # define tls1_suiteb(s)  (s->cert->cert_flags & SSL_CERT_FLAG_SUITEB_128_LOS)
@@ -705,6 +717,8 @@ typedef struct cert_st {
     int alpn_sent;                  /* client */
     /* Count of the number of consecutive warning alerts received */
     unsigned int alert_count;
+    /* This is set if peer supports MPKAC (Multiple Public Key Algorithm Certificate). */
+    unsigned char peer_mpkac_support;
 } CERT;
 
 typedef struct sess_cert_st {
diff --git a/ssl/ssl_rsa.c b/ssl/ssl_rsa.c
index af03d45..1d6650c 100644
--- a/ssl/ssl_rsa.c
+++ b/ssl/ssl_rsa.c
@@ -55,6 +55,77 @@
  * copied and put under another distribution licence
  * [including the GNU Public Licence.]
  */
+/* ====================================================================
+ * Isara Corporation Quantum Safe EST Proprietary Software License
+ * Statement
+ *
+ * LICENSE AGREEMENT: The Product(s) that reference this license include
+ * embedded proprietary software and software “plug-ins” in source code or
+ * object code or both (the “Software”) and accompanying materials (the
+ * “Documentation”) that are subject to the license terms and restrictions
+ * described below (the “License"). If you do not agree to the License
+ * terms, do not use the Product, notify Isara Corporation (“Isara”) by
+ * electronic mail at sales@isara.com and erase any copies of the Product
+ * in your possession. If you are entering into this License on behalf of
+ * a company or other legal entity, you represent that you have the right
+ * to bind that entity to all terms, and “you” refers both to you
+ * personally and such entity.
+ *
+ * USE AND DISTRIBUTION: You may use the Software only in the form and in
+ * the Product(s) delivered to you for the purposes of integration,
+ * development and testing with your own products and/or as part of a
+ * monitoring and/or control group beta test with third parties that agree
+ * in writing to be bound by the terms of this License.
+ *
+ * ADDITIONAL RESTRICTIONS: You shall not use, modify, reproduce, reverse
+ * engineer, disassemble, decompile or otherwise attempt to derive source
+ * code from the Software (except to the extent that such limitations may
+ * not be prohibited by law), sublicense, or distribute the Software or
+ * Documentation other than as permitted by this License. You shall not
+ * remove any proprietary notices, labels or marks on the Product(s) “ZIP
+ * file”, Software or Documentation. No license is granted to use or
+ * reproduce any Isara trademarks.
+ *
+ * OWNERSHIP AND NOTICE: Except for the limited rights granted above,
+ * Isara and its suppliers retain all right, title and interest in and to
+ * the Software and Documentation, including copyrights, patents, trade
+ * secrets and other proprietary rights. Certain components of the
+ * Software that are subject to open source and third party licenses, the
+ * terms and conditions of which can found at https://github.com/cisco and
+ * select the applicable hash-sigs or libest license filed on the Github
+ * repository. If you require additional guidance, notify sales@isara.com
+ * for assistance. As a condition of the License, you agree to comply with
+ * all of the foregoing open source and third party license terms. Unless
+ * required by applicable law, such components are provided on an ‘AS IS’
+ * BASIS, WITHOUT EXPRESS OR IMPLIED WARRANTIES OR CONDITIONS OF ANY KIND.
+ *
+ * WARRANTY DISCLAIMER: THE SOFTWARE AND DOCUMENTATION ARE PROVIDED TO YOU
+ * "AS IS", AND YOU ASSUME THE ENTIRE RISK OF THEIR USE. ISARA AND ITS
+ * SUPPLIERS MAKES NO WARRANTIES OR CONDITIONS, EXPRESS, IMPLIED,
+ * STATUTORY OR IN ANY COMMUNICATION WITH YOU, AND ISARA CORPORATION
+ * EXPRESSLY DISCLAIMS ANY IMPLIED WARRANTIES OF MERCHANTABILITY, FITNESS
+ * FOR A PARTICULAR PURPOSE OR NONINFRINGEMENT WITH RESPECT TO THE
+ * SOFTWARE (INCLUDING ANY MODIFICATIONS MADE THERETO BY ANY PERSON
+ * WHETHER OR NOT AN EMPLOYEE OR CONTRACTOR OF ISARA) OR DOCUMENTATION
+ * PROVIDED TO YOU. ISARA EMPLOYEES AND OTHER PERSONNEL ARE NOT AUTHORIZED
+ * TO MAKE ANY WARRANTY THAT IS INCONSISTENT WITH THIS DISCLAIMER.
+ *
+ * LIMITATION OF LIABILITY: IN NO EVENT WILL ISARA OR ITS SUPPLIERS AND
+ * SUPPLIERS BE LIABLE FOR LOSS OF DATA, LOST PROFITS, COST OF COVER, OR
+ * OTHER SPECIAL, INCIDENTAL, PUNITIVE, CONSEQUENTIAL, OR INDIRECT DAMAGES
+ * ARISING FROM USE OF THE SOFTWARE OR DOCUMENTATION, HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, AND REGARDLESS OF WHETHER ISARA OR ITS
+ * SUPPLIERS HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  ISARA
+ * AND ITS SUPPLIERS BEAR NO LIABILITY FOR ANY PROGRAMS OR DATA STORED IN
+ * OR USED WITH THIS PRODUCT, INCLUDING THE COST OF RECOVERING SUCH
+ * PROGRAMS OR DATA.
+ *
+ * Copyright (c) 2017 ISARA Corporation. All Rights Reserved. This file
+ * contains Proprietary information of Isara Corporation. Unauthorized
+ * copying or use of this file via any medium is strictly prohibited.
+ * Written by Jerry Sui, jerry.sui@isara.com; Daniel Van Geest,
+ * daniel.vangeest@isara.com, December, 2017.
+ */
 
 #include <stdio.h>
 #include "ssl_locl.h"
@@ -62,6 +133,7 @@
 #include <openssl/objects.h>
 #include <openssl/evp.h>
 #include <openssl/x509.h>
+#include <openssl/x509v3.h>
 #include <openssl/pem.h>
 
 static int ssl_set_cert(CERT *c, X509 *x509);
@@ -231,12 +303,73 @@ static int ssl_set_pkey(CERT *c, EVP_PKEY *pkey)
         EVP_PKEY_free(c->pkeys[i].privatekey);
     CRYPTO_add(&pkey->references, 1, CRYPTO_LOCK_EVP_PKEY);
     c->pkeys[i].privatekey = pkey;
+    c->pkeys[i].is_mpka_key = 0;
+
     c->key = &(c->pkeys[i]);
 
     c->valid = 0;
     return (1);
 }
 
+static int ssl_set_alt_pkey(CERT *c, EVP_PKEY *pkey)
+{
+    EVP_PKEY *alt_pub_key = NULL;
+    int ret = 0;
+
+    int i = ssl_cert_type(NULL, pkey);
+    if (i < 0) {
+        SSLerr(SSL_F_SSL_SET_ALT_PKEY, SSL_R_UNKNOWN_CERTIFICATE_TYPE);
+        return (0);
+    }
+
+    if (c->pkeys[i].x509 != NULL) {
+        /* Get the QS ALT PKEY. */
+        alt_pub_key = SSL_get_alt_pubkey(c->pkeys[i].x509);
+        if (alt_pub_key == NULL) {
+            SSLerr(SSL_F_SSL_SET_ALT_PKEY, SSL_R_UNKNOWN_CERTIFICATE_TYPE);
+            return (0);
+        }
+
+        /* Check if there is a cert/key mismatch. */
+        ret = EVP_PKEY_cmp(alt_pub_key, pkey);
+
+        switch (ret) {
+            case 1:
+                break;
+            case 0:
+                SSLerr(SSL_F_SSL_SET_ALT_PKEY, X509_R_KEY_VALUES_MISMATCH);
+                break;
+            case -1:
+                SSLerr(SSL_F_SSL_SET_ALT_PKEY, X509_R_KEY_TYPE_MISMATCH);
+                break;
+            case -2:
+                SSLerr(SSL_F_SSL_SET_ALT_PKEY, X509_R_UNKNOWN_KEY_TYPE);
+                break;
+        }
+
+        if (ret <= 0) {
+            EVP_PKEY_free(alt_pub_key);
+            X509_free(c->pkeys[i].x509);
+            c->pkeys[i].x509 = NULL;
+
+            return (0);
+        }
+    }
+
+    EVP_PKEY_free(alt_pub_key);
+
+    if (c->pkeys[i].privatekey != NULL) {
+        EVP_PKEY_free(c->pkeys[i].privatekey);
+    }
+
+    CRYPTO_add(&pkey->references, 1, CRYPTO_LOCK_EVP_PKEY);
+
+    c->pkeys[i].privatekey = pkey;
+    c->pkeys[i].is_mpka_key = 1;
+
+    return (1);
+}
+
 #ifndef OPENSSL_NO_RSA
 # ifndef OPENSSL_NO_STDIO
 int SSL_use_RSAPrivateKey_file(SSL *ssl, const char *file, int type)
@@ -391,8 +524,10 @@ int SSL_CTX_use_certificate(SSL_CTX *ctx, X509 *x)
 
 static int ssl_set_cert(CERT *c, X509 *x)
 {
-    EVP_PKEY *pkey;
-    int i;
+    EVP_PKEY *pkey = 0;
+    int i = 0;
+    int alt_pub_key_idx = -1;
+    EVP_PKEY *alt_pub_key = NULL;
 
     pkey = X509_get_pubkey(x);
     if (pkey == NULL) {
@@ -439,6 +574,7 @@ static int ssl_set_cert(CERT *c, X509 *x)
     }
 
     EVP_PKEY_free(pkey);
+    c->pkeys[i].is_mpka_cert = 0;
 
     if (c->pkeys[i].x509 != NULL)
         X509_free(c->pkeys[i].x509);
@@ -447,6 +583,65 @@ static int ssl_set_cert(CERT *c, X509 *x)
     c->key = &(c->pkeys[i]);
 
     c->valid = 0;
+
+    alt_pub_key_idx = X509_get_ext_by_NID(x, NID_subj_alt_pub_key, -1);
+    if (alt_pub_key_idx >= 0 ) {
+        /* Get the QS ALT PKEY. */
+        alt_pub_key = SSL_get_alt_pubkey(x);
+        if (alt_pub_key == NULL) {
+            SSLerr(SSL_F_SSL_SET_CERT, SSL_R_UNKNOWN_CERTIFICATE_TYPE);
+            return (0);
+        }
+
+        /* Mark the previous pkey (before updating the index "i"),
+         * because it also refers to an MPKA cert.
+         */
+        c->pkeys[i].is_mpka_cert = 1;
+
+        i = ssl_cert_type(x, alt_pub_key);
+        if (i < 0) {
+            SSLerr(SSL_F_SSL_SET_CERT, SSL_R_UNKNOWN_CERTIFICATE_TYPE);
+            EVP_PKEY_free(alt_pub_key);
+            return (0);
+        }
+
+        if (c->pkeys[i].privatekey != NULL) {
+            /* Check if there is a cert/key mismatch. */
+            int ret = EVP_PKEY_cmp(alt_pub_key, c->pkeys[i].privatekey);
+
+            switch (ret) {
+                case 1:
+                    break;
+                case 0:
+                    SSLerr(SSL_F_SSL_SET_CERT, X509_R_KEY_VALUES_MISMATCH);
+                    break;
+                case -1:
+                    SSLerr(SSL_F_SSL_SET_CERT, X509_R_KEY_TYPE_MISMATCH);
+                    break;
+                case -2:
+                    SSLerr(SSL_F_SSL_SET_CERT, X509_R_UNKNOWN_KEY_TYPE);
+                    break;
+            }
+
+            if (ret <= 0) {
+                EVP_PKEY_free(c->pkeys[i].privatekey);
+                c->pkeys[i].privatekey = NULL;
+                /* clear error queue */
+                ERR_clear_error();
+            }
+        }
+
+        EVP_PKEY_free(alt_pub_key);
+
+        if (c->pkeys[i].x509 != NULL) {
+            X509_free(c->pkeys[i].x509);
+        }
+
+        CRYPTO_add(&x->references, 1, CRYPTO_LOCK_X509);
+        c->pkeys[i].x509 = x;
+        c->pkeys[i].is_mpka_cert = 1;
+    }
+
     return (1);
 }
 
@@ -616,6 +811,19 @@ int SSL_CTX_use_PrivateKey(SSL_CTX *ctx, EVP_PKEY *pkey)
     return (ssl_set_pkey(ctx->cert, pkey));
 }
 
+int SSL_CTX_use_ALTPrivateKey(SSL_CTX *ctx, EVP_PKEY *pkey)
+{
+    if (pkey == NULL) {
+        SSLerr(SSL_F_SSL_CTX_USE_ALTPRIVATEKEY, ERR_R_PASSED_NULL_PARAMETER);
+        return (0);
+    }
+    if (!ssl_cert_inst(&ctx->cert)) {
+        SSLerr(SSL_F_SSL_CTX_USE_ALTPRIVATEKEY, ERR_R_MALLOC_FAILURE);
+        return (0);
+    }
+    return (ssl_set_alt_pkey(ctx->cert, pkey));
+}
+
 #ifndef OPENSSL_NO_STDIO
 int SSL_CTX_use_PrivateKey_file(SSL_CTX *ctx, const char *file, int type)
 {
@@ -656,6 +864,46 @@ int SSL_CTX_use_PrivateKey_file(SSL_CTX *ctx, const char *file, int type)
         BIO_free(in);
     return (ret);
 }
+
+int SSL_CTX_use_ALTPrivateKey_file(SSL_CTX *ctx, const char *file, int type)
+{
+    int j, ret = 0;
+    BIO *in = NULL;
+    EVP_PKEY *pkey = NULL;
+
+    in = BIO_new(BIO_s_file_internal());
+    if (in == NULL) {
+        SSLerr(SSL_F_SSL_CTX_USE_ALTPRIVATEKEY_FILE, ERR_R_BUF_LIB);
+        goto end;
+    }
+
+    if (BIO_read_filename(in, file) <= 0) {
+        SSLerr(SSL_F_SSL_CTX_USE_ALTPRIVATEKEY_FILE, ERR_R_SYS_LIB);
+        goto end;
+    }
+    if (type == SSL_FILETYPE_PEM) {
+        j = ERR_R_PEM_LIB;
+        pkey = PEM_read_bio_PrivateKey(in, NULL,
+                                       ctx->default_passwd_callback,
+                                       ctx->default_passwd_callback_userdata);
+    } else if (type == SSL_FILETYPE_ASN1) {
+        j = ERR_R_ASN1_LIB;
+        pkey = d2i_PrivateKey_bio(in, NULL);
+    } else {
+        SSLerr(SSL_F_SSL_CTX_USE_ALTPRIVATEKEY_FILE, SSL_R_BAD_SSL_FILETYPE);
+        goto end;
+    }
+    if (pkey == NULL) {
+        SSLerr(SSL_F_SSL_CTX_USE_ALTPRIVATEKEY_FILE, j);
+        goto end;
+    }
+    ret = SSL_CTX_use_ALTPrivateKey(ctx, pkey);
+    EVP_PKEY_free(pkey);
+ end:
+    if (in != NULL)
+        BIO_free(in);
+    return (ret);
+}
 #endif
 
 int SSL_CTX_use_PrivateKey_ASN1(int type, SSL_CTX *ctx,
@@ -676,6 +924,24 @@ int SSL_CTX_use_PrivateKey_ASN1(int type, SSL_CTX *ctx,
     return (ret);
 }
 
+int SSL_CTX_use_ALTPrivateKey_ASN1(int type, SSL_CTX *ctx,
+                                const unsigned char *d, long len)
+{
+    int ret = 0;
+    const unsigned char *p = NULL;
+    EVP_PKEY *pkey = NULL;
+
+    p = d;
+    if ((pkey = d2i_PrivateKey(type, NULL, &p, (long)len)) == NULL) {
+        SSLerr(SSL_F_SSL_CTX_USE_ALTPRIVATEKEY_ASN1, ERR_R_ASN1_LIB);
+        return (0);
+    }
+
+    ret = SSL_CTX_use_ALTPrivateKey(ctx, pkey);
+    EVP_PKEY_free(pkey);
+    return (ret);
+}
+
 #ifndef OPENSSL_NO_STDIO
 /*
  * Read a file that contains our certificate in "PEM" format, possibly
diff --git a/ssl/t1_lib.c b/ssl/t1_lib.c
index b398b61..2a04c46 100644
--- a/ssl/t1_lib.c
+++ b/ssl/t1_lib.c
@@ -1009,6 +1009,20 @@ static int tls1_check_cert_param(SSL *s, X509 *x, int set_ee_md)
 #  define tlsext_sigalg_hss(md) md, TLSEXT_signature_hss,
 # endif
 
+# ifdef OPENSSL_NO_MPKAC
+#  define tlsext_sigalg_mpkac(md) /* */
+# else
+/* This does not define a signature algorithm per se,
+ * but to suggest to the peer that it supports the
+ * "alternative" signature algorithm in MPKAC
+ * (Multiple Public Key Algorithm Certificate).
+ *
+ * The paired hash algo is not used, and its purpose is to
+ * make it fit better in tls12_sigalgs.
+ */
+#  define tlsext_sigalg_mpkac(md) md, TLSEXT_signature_mpkac,
+# endif
+
 # ifdef OPENSSL_NO_ECDSA
 #  define tlsext_sigalg_ecdsa(md)
                                 /* */
@@ -1035,6 +1049,7 @@ static unsigned char tls12_sigalgs[] = {
 # endif
 # ifndef OPENSSL_NO_SHA512
         tlsext_sigalg_hss(TLSEXT_hash_sha512)
+        tlsext_sigalg_mpkac(TLSEXT_hash_sha512)
 # endif
 };
 
@@ -3881,6 +3896,7 @@ static int tls1_set_shared_sigalgs(SSL *s)
 
 int tls1_save_sigalgs(SSL *s, const unsigned char *data, int dsize)
 {
+    int i = 0;
     CERT *c = s->cert;
     /* Extension ignored for inappropriate versions */
     if (!SSL_USE_SIGALGS(s))
@@ -3891,6 +3907,17 @@ int tls1_save_sigalgs(SSL *s, const unsigned char *data, int dsize)
 
     if (c->peer_sigalgs)
         OPENSSL_free(c->peer_sigalgs);
+
+    for (i = 0; i < dsize; i += 2) {
+        /* If the peer supports MPKAC, there should be an entry that is
+         * TLSEXT_signature_mpkac. It serves as a signal rather than specifying
+         * a signing algorithm, and it is OK to be copied to c->peer_sigalgs.
+         */
+        if (data[i+1] == TLSEXT_signature_mpkac) {
+            c->peer_mpkac_support = 1;
+        }
+    }
+
     c->peer_sigalgs = OPENSSL_malloc(dsize);
     if (!c->peer_sigalgs)
         return 0;
diff --git a/ssl/tls1.h b/ssl/tls1.h
index b4eb065..23f7429 100644
--- a/ssl/tls1.h
+++ b/ssl/tls1.h
@@ -281,9 +281,10 @@ extern "C" {
 
  /* Signature and hash algorithms from ISARA */
 # define TLSEXT_signature_hss                            15
+# define TLSEXT_signature_mpkac                          16
 
 /* Total number of different signature algorithms */
-# define TLSEXT_signature_num                            5
+# define TLSEXT_signature_num                            6
 
 # define TLSEXT_hash_none                                0
 # define TLSEXT_hash_md5                                 1
diff --git a/util/libeay.num b/util/libeay.num
index 075a2c8..72e6f84 100755
--- a/util/libeay.num
+++ b/util/libeay.num
@@ -4467,3 +4467,9 @@ i2d_HSS_PUBKEY_bio                      4821	EXIST::FUNCTION:BIO,HSS
 ERR_load_HSSALG_strings                 4822	EXIST::FUNCTION:HSS
 EVP_PKEY_get1_HSS                       4823	EXIST::FUNCTION:HSS
 HSS_new_with_engine                     4824	EXIST::FUNCTION:HSS
+SUBJECT_ALT_PUBLIC_KEY_INFO_free        4825	EXIST::FUNCTION:
+d2i_SUBJECT_ALT_PUBLIC_KEY_INFO         4826	EXIST::FUNCTION:
+SUBJECT_ALT_PUBLIC_KEY_INFO_new         4827	EXIST::FUNCTION:
+i2d_SUBJECT_ALT_PUBLIC_KEY_INFO         4828	EXIST::FUNCTION:
+SUBJECT_ALT_PUBLIC_KEY_INFO_it          4829	EXIST:!EXPORT_VAR_AS_FUNCTION:VARIABLE:
+SUBJECT_ALT_PUBLIC_KEY_INFO_it          4829	EXIST:EXPORT_VAR_AS_FUNCTION:FUNCTION:
diff --git a/util/ssleay.num b/util/ssleay.num
index e3fdaf2..4b2105c 100755
--- a/util/ssleay.num
+++ b/util/ssleay.num
@@ -368,3 +368,7 @@ SSL_CTX_use_serverinfo_file             406	EXIST::FUNCTION:STDIO,TLSEXT
 SSL_COMP_free_compression_methods       407	EXIST:!VMS:FUNCTION:
 SSL_COMP_free_compress_methods          407	EXIST:VMS:FUNCTION:
 SSL_extension_supported                 409	EXIST::FUNCTION:TLSEXT
+SSL_get_alt_pubkey                      410	EXIST::FUNCTION:
+SSL_CTX_use_ALTPrivateKey               411	EXIST::FUNCTION:
+SSL_CTX_use_ALTPrivateKey_ASN1          412	EXIST::FUNCTION:
+SSL_CTX_use_ALTPrivateKey_file          413	EXIST::FUNCTION:STDIO
